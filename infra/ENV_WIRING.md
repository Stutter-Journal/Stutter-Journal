# ENV wiring (MVP)

This describes how environment variables and URLs flow from local machine → Terraform → Kubernetes.

## Stable dev URLs (no hard-coded IPs)

Default is **Mode A (sslip.io)**.

- A local file `.env.runtime` is generated at repo root by the Ansible `dns_mode` role.
- It contains the stable developer-facing URLs:
  - `ELOQUIA_API_URL=http://api.<ip>.sslip.io`
  - `ELOQUIA_APP_URL=http://app.<ip>.sslip.io`

These are intended for humans/tools (`curl`, browsers) and are **not** baked into source code.

## Backend (Go)

Kubernetes wiring:
- `DATABASE_URL` is injected from a Kubernetes Secret created by Terraform.
- `AUTH_COOKIE_SECRET` is injected from a Kubernetes Secret created by Terraform.
- `PORT` is injected via ConfigMap (defaults to `8080` in code).

Runtime behavior:
- `/health` is used for liveness.
- `/ready` is used for readiness and checks DB connectivity.

## Desktop (Nx: portal + bff)

Production routing choice for MVP:
- `app.<host>` serves the Angular SSR portal.
- `app.<host>/api/*` is routed to the NestJS BFF.

This mirrors local dev behavior (`portal` proxying `/api` → `bff`) without requiring browser-side hard-coded API URLs.

BFF upstream:
- The BFF forwards to the Go backend using `ELOQUIA_API_BASE_URL`.
- In Kubernetes, Terraform sets this to the in-cluster Service DNS name (e.g. `http://backend:8080`).

## Postgres

Terraform deploys Postgres via the Bitnami Helm chart.

- Credentials are generated by Terraform (`random_password`).
- A Secret is created and passed to the chart via `auth.existingSecret`.
- Terraform produces an in-cluster `DATABASE_URL` for the backend.

## Notes

- Secrets are not committed to git.
- If the ingress IP changes, re-run `./scripts/up.sh` to regenerate `.env.runtime` and re-apply Terraform.

// Code generated by ent, DO NOT EDIT.

package ent

import (
	"backend/ent/analysisjob"
	"backend/ent/comment"
	"backend/ent/doctor"
	"backend/ent/doctorpatientlink"
	"backend/ent/entry"
	"backend/ent/entryshare"
	"backend/ent/pairingcode"
	"backend/ent/patient"
	"backend/ent/practice"
	"backend/ent/predicate"
	"backend/ent/schema"
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAnalysisJob       = "AnalysisJob"
	TypeComment           = "Comment"
	TypeDoctor            = "Doctor"
	TypeDoctorPatientLink = "DoctorPatientLink"
	TypeEntry             = "Entry"
	TypeEntryShare        = "EntryShare"
	TypePairingCode       = "PairingCode"
	TypePatient           = "Patient"
	TypePractice          = "Practice"
)

// AnalysisJobMutation represents an operation that mutates the AnalysisJob nodes in the graph.
type AnalysisJobMutation struct {
	config
	op                       Op
	typ                      string
	id                       *uuid.UUID
	created_at               *time.Time
	updated_at               *time.Time
	object_key               *string
	kind                     *string
	status                   *analysisjob.Status
	progress                 *int
	addprogress              *int
	result                   *map[string]interface{}
	metrics                  *map[string]interface{}
	error_message            *string
	started_at               *time.Time
	finished_at              *time.Time
	clearedFields            map[string]struct{}
	patient                  *uuid.UUID
	clearedpatient           bool
	created_by_doctor        *uuid.UUID
	clearedcreated_by_doctor bool
	entry                    *uuid.UUID
	clearedentry             bool
	done                     bool
	oldValue                 func(context.Context) (*AnalysisJob, error)
	predicates               []predicate.AnalysisJob
}

var _ ent.Mutation = (*AnalysisJobMutation)(nil)

// analysisjobOption allows management of the mutation configuration using functional options.
type analysisjobOption func(*AnalysisJobMutation)

// newAnalysisJobMutation creates new mutation for the AnalysisJob entity.
func newAnalysisJobMutation(c config, op Op, opts ...analysisjobOption) *AnalysisJobMutation {
	m := &AnalysisJobMutation{
		config:        c,
		op:            op,
		typ:           TypeAnalysisJob,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAnalysisJobID sets the ID field of the mutation.
func withAnalysisJobID(id uuid.UUID) analysisjobOption {
	return func(m *AnalysisJobMutation) {
		var (
			err   error
			once  sync.Once
			value *AnalysisJob
		)
		m.oldValue = func(ctx context.Context) (*AnalysisJob, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AnalysisJob.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAnalysisJob sets the old AnalysisJob of the mutation.
func withAnalysisJob(node *AnalysisJob) analysisjobOption {
	return func(m *AnalysisJobMutation) {
		m.oldValue = func(context.Context) (*AnalysisJob, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AnalysisJobMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AnalysisJobMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AnalysisJob entities.
func (m *AnalysisJobMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AnalysisJobMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AnalysisJobMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AnalysisJob.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AnalysisJobMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AnalysisJobMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AnalysisJob entity.
// If the AnalysisJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnalysisJobMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AnalysisJobMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AnalysisJobMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AnalysisJobMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AnalysisJob entity.
// If the AnalysisJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnalysisJobMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AnalysisJobMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetPatientID sets the "patient_id" field.
func (m *AnalysisJobMutation) SetPatientID(u uuid.UUID) {
	m.patient = &u
}

// PatientID returns the value of the "patient_id" field in the mutation.
func (m *AnalysisJobMutation) PatientID() (r uuid.UUID, exists bool) {
	v := m.patient
	if v == nil {
		return
	}
	return *v, true
}

// OldPatientID returns the old "patient_id" field's value of the AnalysisJob entity.
// If the AnalysisJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnalysisJobMutation) OldPatientID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPatientID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPatientID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPatientID: %w", err)
	}
	return oldValue.PatientID, nil
}

// ResetPatientID resets all changes to the "patient_id" field.
func (m *AnalysisJobMutation) ResetPatientID() {
	m.patient = nil
}

// SetCreatedByDoctorID sets the "created_by_doctor_id" field.
func (m *AnalysisJobMutation) SetCreatedByDoctorID(u uuid.UUID) {
	m.created_by_doctor = &u
}

// CreatedByDoctorID returns the value of the "created_by_doctor_id" field in the mutation.
func (m *AnalysisJobMutation) CreatedByDoctorID() (r uuid.UUID, exists bool) {
	v := m.created_by_doctor
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedByDoctorID returns the old "created_by_doctor_id" field's value of the AnalysisJob entity.
// If the AnalysisJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnalysisJobMutation) OldCreatedByDoctorID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedByDoctorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedByDoctorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedByDoctorID: %w", err)
	}
	return oldValue.CreatedByDoctorID, nil
}

// ResetCreatedByDoctorID resets all changes to the "created_by_doctor_id" field.
func (m *AnalysisJobMutation) ResetCreatedByDoctorID() {
	m.created_by_doctor = nil
}

// SetObjectKey sets the "object_key" field.
func (m *AnalysisJobMutation) SetObjectKey(s string) {
	m.object_key = &s
}

// ObjectKey returns the value of the "object_key" field in the mutation.
func (m *AnalysisJobMutation) ObjectKey() (r string, exists bool) {
	v := m.object_key
	if v == nil {
		return
	}
	return *v, true
}

// OldObjectKey returns the old "object_key" field's value of the AnalysisJob entity.
// If the AnalysisJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnalysisJobMutation) OldObjectKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldObjectKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldObjectKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldObjectKey: %w", err)
	}
	return oldValue.ObjectKey, nil
}

// ResetObjectKey resets all changes to the "object_key" field.
func (m *AnalysisJobMutation) ResetObjectKey() {
	m.object_key = nil
}

// SetKind sets the "kind" field.
func (m *AnalysisJobMutation) SetKind(s string) {
	m.kind = &s
}

// Kind returns the value of the "kind" field in the mutation.
func (m *AnalysisJobMutation) Kind() (r string, exists bool) {
	v := m.kind
	if v == nil {
		return
	}
	return *v, true
}

// OldKind returns the old "kind" field's value of the AnalysisJob entity.
// If the AnalysisJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnalysisJobMutation) OldKind(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKind: %w", err)
	}
	return oldValue.Kind, nil
}

// ResetKind resets all changes to the "kind" field.
func (m *AnalysisJobMutation) ResetKind() {
	m.kind = nil
}

// SetStatus sets the "status" field.
func (m *AnalysisJobMutation) SetStatus(a analysisjob.Status) {
	m.status = &a
}

// Status returns the value of the "status" field in the mutation.
func (m *AnalysisJobMutation) Status() (r analysisjob.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the AnalysisJob entity.
// If the AnalysisJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnalysisJobMutation) OldStatus(ctx context.Context) (v analysisjob.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *AnalysisJobMutation) ResetStatus() {
	m.status = nil
}

// SetProgress sets the "progress" field.
func (m *AnalysisJobMutation) SetProgress(i int) {
	m.progress = &i
	m.addprogress = nil
}

// Progress returns the value of the "progress" field in the mutation.
func (m *AnalysisJobMutation) Progress() (r int, exists bool) {
	v := m.progress
	if v == nil {
		return
	}
	return *v, true
}

// OldProgress returns the old "progress" field's value of the AnalysisJob entity.
// If the AnalysisJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnalysisJobMutation) OldProgress(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProgress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProgress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProgress: %w", err)
	}
	return oldValue.Progress, nil
}

// AddProgress adds i to the "progress" field.
func (m *AnalysisJobMutation) AddProgress(i int) {
	if m.addprogress != nil {
		*m.addprogress += i
	} else {
		m.addprogress = &i
	}
}

// AddedProgress returns the value that was added to the "progress" field in this mutation.
func (m *AnalysisJobMutation) AddedProgress() (r int, exists bool) {
	v := m.addprogress
	if v == nil {
		return
	}
	return *v, true
}

// ClearProgress clears the value of the "progress" field.
func (m *AnalysisJobMutation) ClearProgress() {
	m.progress = nil
	m.addprogress = nil
	m.clearedFields[analysisjob.FieldProgress] = struct{}{}
}

// ProgressCleared returns if the "progress" field was cleared in this mutation.
func (m *AnalysisJobMutation) ProgressCleared() bool {
	_, ok := m.clearedFields[analysisjob.FieldProgress]
	return ok
}

// ResetProgress resets all changes to the "progress" field.
func (m *AnalysisJobMutation) ResetProgress() {
	m.progress = nil
	m.addprogress = nil
	delete(m.clearedFields, analysisjob.FieldProgress)
}

// SetResult sets the "result" field.
func (m *AnalysisJobMutation) SetResult(value map[string]interface{}) {
	m.result = &value
}

// Result returns the value of the "result" field in the mutation.
func (m *AnalysisJobMutation) Result() (r map[string]interface{}, exists bool) {
	v := m.result
	if v == nil {
		return
	}
	return *v, true
}

// OldResult returns the old "result" field's value of the AnalysisJob entity.
// If the AnalysisJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnalysisJobMutation) OldResult(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResult is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResult requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResult: %w", err)
	}
	return oldValue.Result, nil
}

// ClearResult clears the value of the "result" field.
func (m *AnalysisJobMutation) ClearResult() {
	m.result = nil
	m.clearedFields[analysisjob.FieldResult] = struct{}{}
}

// ResultCleared returns if the "result" field was cleared in this mutation.
func (m *AnalysisJobMutation) ResultCleared() bool {
	_, ok := m.clearedFields[analysisjob.FieldResult]
	return ok
}

// ResetResult resets all changes to the "result" field.
func (m *AnalysisJobMutation) ResetResult() {
	m.result = nil
	delete(m.clearedFields, analysisjob.FieldResult)
}

// SetMetrics sets the "metrics" field.
func (m *AnalysisJobMutation) SetMetrics(value map[string]interface{}) {
	m.metrics = &value
}

// Metrics returns the value of the "metrics" field in the mutation.
func (m *AnalysisJobMutation) Metrics() (r map[string]interface{}, exists bool) {
	v := m.metrics
	if v == nil {
		return
	}
	return *v, true
}

// OldMetrics returns the old "metrics" field's value of the AnalysisJob entity.
// If the AnalysisJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnalysisJobMutation) OldMetrics(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetrics is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetrics requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetrics: %w", err)
	}
	return oldValue.Metrics, nil
}

// ClearMetrics clears the value of the "metrics" field.
func (m *AnalysisJobMutation) ClearMetrics() {
	m.metrics = nil
	m.clearedFields[analysisjob.FieldMetrics] = struct{}{}
}

// MetricsCleared returns if the "metrics" field was cleared in this mutation.
func (m *AnalysisJobMutation) MetricsCleared() bool {
	_, ok := m.clearedFields[analysisjob.FieldMetrics]
	return ok
}

// ResetMetrics resets all changes to the "metrics" field.
func (m *AnalysisJobMutation) ResetMetrics() {
	m.metrics = nil
	delete(m.clearedFields, analysisjob.FieldMetrics)
}

// SetErrorMessage sets the "error_message" field.
func (m *AnalysisJobMutation) SetErrorMessage(s string) {
	m.error_message = &s
}

// ErrorMessage returns the value of the "error_message" field in the mutation.
func (m *AnalysisJobMutation) ErrorMessage() (r string, exists bool) {
	v := m.error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMessage returns the old "error_message" field's value of the AnalysisJob entity.
// If the AnalysisJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnalysisJobMutation) OldErrorMessage(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMessage: %w", err)
	}
	return oldValue.ErrorMessage, nil
}

// ClearErrorMessage clears the value of the "error_message" field.
func (m *AnalysisJobMutation) ClearErrorMessage() {
	m.error_message = nil
	m.clearedFields[analysisjob.FieldErrorMessage] = struct{}{}
}

// ErrorMessageCleared returns if the "error_message" field was cleared in this mutation.
func (m *AnalysisJobMutation) ErrorMessageCleared() bool {
	_, ok := m.clearedFields[analysisjob.FieldErrorMessage]
	return ok
}

// ResetErrorMessage resets all changes to the "error_message" field.
func (m *AnalysisJobMutation) ResetErrorMessage() {
	m.error_message = nil
	delete(m.clearedFields, analysisjob.FieldErrorMessage)
}

// SetStartedAt sets the "started_at" field.
func (m *AnalysisJobMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *AnalysisJobMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the AnalysisJob entity.
// If the AnalysisJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnalysisJobMutation) OldStartedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ClearStartedAt clears the value of the "started_at" field.
func (m *AnalysisJobMutation) ClearStartedAt() {
	m.started_at = nil
	m.clearedFields[analysisjob.FieldStartedAt] = struct{}{}
}

// StartedAtCleared returns if the "started_at" field was cleared in this mutation.
func (m *AnalysisJobMutation) StartedAtCleared() bool {
	_, ok := m.clearedFields[analysisjob.FieldStartedAt]
	return ok
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *AnalysisJobMutation) ResetStartedAt() {
	m.started_at = nil
	delete(m.clearedFields, analysisjob.FieldStartedAt)
}

// SetFinishedAt sets the "finished_at" field.
func (m *AnalysisJobMutation) SetFinishedAt(t time.Time) {
	m.finished_at = &t
}

// FinishedAt returns the value of the "finished_at" field in the mutation.
func (m *AnalysisJobMutation) FinishedAt() (r time.Time, exists bool) {
	v := m.finished_at
	if v == nil {
		return
	}
	return *v, true
}

// OldFinishedAt returns the old "finished_at" field's value of the AnalysisJob entity.
// If the AnalysisJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnalysisJobMutation) OldFinishedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFinishedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFinishedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFinishedAt: %w", err)
	}
	return oldValue.FinishedAt, nil
}

// ClearFinishedAt clears the value of the "finished_at" field.
func (m *AnalysisJobMutation) ClearFinishedAt() {
	m.finished_at = nil
	m.clearedFields[analysisjob.FieldFinishedAt] = struct{}{}
}

// FinishedAtCleared returns if the "finished_at" field was cleared in this mutation.
func (m *AnalysisJobMutation) FinishedAtCleared() bool {
	_, ok := m.clearedFields[analysisjob.FieldFinishedAt]
	return ok
}

// ResetFinishedAt resets all changes to the "finished_at" field.
func (m *AnalysisJobMutation) ResetFinishedAt() {
	m.finished_at = nil
	delete(m.clearedFields, analysisjob.FieldFinishedAt)
}

// SetEntryID sets the "entry_id" field.
func (m *AnalysisJobMutation) SetEntryID(u uuid.UUID) {
	m.entry = &u
}

// EntryID returns the value of the "entry_id" field in the mutation.
func (m *AnalysisJobMutation) EntryID() (r uuid.UUID, exists bool) {
	v := m.entry
	if v == nil {
		return
	}
	return *v, true
}

// OldEntryID returns the old "entry_id" field's value of the AnalysisJob entity.
// If the AnalysisJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnalysisJobMutation) OldEntryID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntryID: %w", err)
	}
	return oldValue.EntryID, nil
}

// ClearEntryID clears the value of the "entry_id" field.
func (m *AnalysisJobMutation) ClearEntryID() {
	m.entry = nil
	m.clearedFields[analysisjob.FieldEntryID] = struct{}{}
}

// EntryIDCleared returns if the "entry_id" field was cleared in this mutation.
func (m *AnalysisJobMutation) EntryIDCleared() bool {
	_, ok := m.clearedFields[analysisjob.FieldEntryID]
	return ok
}

// ResetEntryID resets all changes to the "entry_id" field.
func (m *AnalysisJobMutation) ResetEntryID() {
	m.entry = nil
	delete(m.clearedFields, analysisjob.FieldEntryID)
}

// ClearPatient clears the "patient" edge to the Patient entity.
func (m *AnalysisJobMutation) ClearPatient() {
	m.clearedpatient = true
	m.clearedFields[analysisjob.FieldPatientID] = struct{}{}
}

// PatientCleared reports if the "patient" edge to the Patient entity was cleared.
func (m *AnalysisJobMutation) PatientCleared() bool {
	return m.clearedpatient
}

// PatientIDs returns the "patient" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PatientID instead. It exists only for internal usage by the builders.
func (m *AnalysisJobMutation) PatientIDs() (ids []uuid.UUID) {
	if id := m.patient; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPatient resets all changes to the "patient" edge.
func (m *AnalysisJobMutation) ResetPatient() {
	m.patient = nil
	m.clearedpatient = false
}

// ClearCreatedByDoctor clears the "created_by_doctor" edge to the Doctor entity.
func (m *AnalysisJobMutation) ClearCreatedByDoctor() {
	m.clearedcreated_by_doctor = true
	m.clearedFields[analysisjob.FieldCreatedByDoctorID] = struct{}{}
}

// CreatedByDoctorCleared reports if the "created_by_doctor" edge to the Doctor entity was cleared.
func (m *AnalysisJobMutation) CreatedByDoctorCleared() bool {
	return m.clearedcreated_by_doctor
}

// CreatedByDoctorIDs returns the "created_by_doctor" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatedByDoctorID instead. It exists only for internal usage by the builders.
func (m *AnalysisJobMutation) CreatedByDoctorIDs() (ids []uuid.UUID) {
	if id := m.created_by_doctor; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreatedByDoctor resets all changes to the "created_by_doctor" edge.
func (m *AnalysisJobMutation) ResetCreatedByDoctor() {
	m.created_by_doctor = nil
	m.clearedcreated_by_doctor = false
}

// ClearEntry clears the "entry" edge to the Entry entity.
func (m *AnalysisJobMutation) ClearEntry() {
	m.clearedentry = true
	m.clearedFields[analysisjob.FieldEntryID] = struct{}{}
}

// EntryCleared reports if the "entry" edge to the Entry entity was cleared.
func (m *AnalysisJobMutation) EntryCleared() bool {
	return m.EntryIDCleared() || m.clearedentry
}

// EntryIDs returns the "entry" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EntryID instead. It exists only for internal usage by the builders.
func (m *AnalysisJobMutation) EntryIDs() (ids []uuid.UUID) {
	if id := m.entry; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEntry resets all changes to the "entry" edge.
func (m *AnalysisJobMutation) ResetEntry() {
	m.entry = nil
	m.clearedentry = false
}

// Where appends a list predicates to the AnalysisJobMutation builder.
func (m *AnalysisJobMutation) Where(ps ...predicate.AnalysisJob) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AnalysisJobMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AnalysisJobMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AnalysisJob, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AnalysisJobMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AnalysisJobMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AnalysisJob).
func (m *AnalysisJobMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AnalysisJobMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_at != nil {
		fields = append(fields, analysisjob.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, analysisjob.FieldUpdatedAt)
	}
	if m.patient != nil {
		fields = append(fields, analysisjob.FieldPatientID)
	}
	if m.created_by_doctor != nil {
		fields = append(fields, analysisjob.FieldCreatedByDoctorID)
	}
	if m.object_key != nil {
		fields = append(fields, analysisjob.FieldObjectKey)
	}
	if m.kind != nil {
		fields = append(fields, analysisjob.FieldKind)
	}
	if m.status != nil {
		fields = append(fields, analysisjob.FieldStatus)
	}
	if m.progress != nil {
		fields = append(fields, analysisjob.FieldProgress)
	}
	if m.result != nil {
		fields = append(fields, analysisjob.FieldResult)
	}
	if m.metrics != nil {
		fields = append(fields, analysisjob.FieldMetrics)
	}
	if m.error_message != nil {
		fields = append(fields, analysisjob.FieldErrorMessage)
	}
	if m.started_at != nil {
		fields = append(fields, analysisjob.FieldStartedAt)
	}
	if m.finished_at != nil {
		fields = append(fields, analysisjob.FieldFinishedAt)
	}
	if m.entry != nil {
		fields = append(fields, analysisjob.FieldEntryID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AnalysisJobMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case analysisjob.FieldCreatedAt:
		return m.CreatedAt()
	case analysisjob.FieldUpdatedAt:
		return m.UpdatedAt()
	case analysisjob.FieldPatientID:
		return m.PatientID()
	case analysisjob.FieldCreatedByDoctorID:
		return m.CreatedByDoctorID()
	case analysisjob.FieldObjectKey:
		return m.ObjectKey()
	case analysisjob.FieldKind:
		return m.Kind()
	case analysisjob.FieldStatus:
		return m.Status()
	case analysisjob.FieldProgress:
		return m.Progress()
	case analysisjob.FieldResult:
		return m.Result()
	case analysisjob.FieldMetrics:
		return m.Metrics()
	case analysisjob.FieldErrorMessage:
		return m.ErrorMessage()
	case analysisjob.FieldStartedAt:
		return m.StartedAt()
	case analysisjob.FieldFinishedAt:
		return m.FinishedAt()
	case analysisjob.FieldEntryID:
		return m.EntryID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AnalysisJobMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case analysisjob.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case analysisjob.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case analysisjob.FieldPatientID:
		return m.OldPatientID(ctx)
	case analysisjob.FieldCreatedByDoctorID:
		return m.OldCreatedByDoctorID(ctx)
	case analysisjob.FieldObjectKey:
		return m.OldObjectKey(ctx)
	case analysisjob.FieldKind:
		return m.OldKind(ctx)
	case analysisjob.FieldStatus:
		return m.OldStatus(ctx)
	case analysisjob.FieldProgress:
		return m.OldProgress(ctx)
	case analysisjob.FieldResult:
		return m.OldResult(ctx)
	case analysisjob.FieldMetrics:
		return m.OldMetrics(ctx)
	case analysisjob.FieldErrorMessage:
		return m.OldErrorMessage(ctx)
	case analysisjob.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case analysisjob.FieldFinishedAt:
		return m.OldFinishedAt(ctx)
	case analysisjob.FieldEntryID:
		return m.OldEntryID(ctx)
	}
	return nil, fmt.Errorf("unknown AnalysisJob field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AnalysisJobMutation) SetField(name string, value ent.Value) error {
	switch name {
	case analysisjob.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case analysisjob.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case analysisjob.FieldPatientID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPatientID(v)
		return nil
	case analysisjob.FieldCreatedByDoctorID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedByDoctorID(v)
		return nil
	case analysisjob.FieldObjectKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetObjectKey(v)
		return nil
	case analysisjob.FieldKind:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKind(v)
		return nil
	case analysisjob.FieldStatus:
		v, ok := value.(analysisjob.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case analysisjob.FieldProgress:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProgress(v)
		return nil
	case analysisjob.FieldResult:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResult(v)
		return nil
	case analysisjob.FieldMetrics:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetrics(v)
		return nil
	case analysisjob.FieldErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMessage(v)
		return nil
	case analysisjob.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case analysisjob.FieldFinishedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFinishedAt(v)
		return nil
	case analysisjob.FieldEntryID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntryID(v)
		return nil
	}
	return fmt.Errorf("unknown AnalysisJob field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AnalysisJobMutation) AddedFields() []string {
	var fields []string
	if m.addprogress != nil {
		fields = append(fields, analysisjob.FieldProgress)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AnalysisJobMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case analysisjob.FieldProgress:
		return m.AddedProgress()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AnalysisJobMutation) AddField(name string, value ent.Value) error {
	switch name {
	case analysisjob.FieldProgress:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProgress(v)
		return nil
	}
	return fmt.Errorf("unknown AnalysisJob numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AnalysisJobMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(analysisjob.FieldProgress) {
		fields = append(fields, analysisjob.FieldProgress)
	}
	if m.FieldCleared(analysisjob.FieldResult) {
		fields = append(fields, analysisjob.FieldResult)
	}
	if m.FieldCleared(analysisjob.FieldMetrics) {
		fields = append(fields, analysisjob.FieldMetrics)
	}
	if m.FieldCleared(analysisjob.FieldErrorMessage) {
		fields = append(fields, analysisjob.FieldErrorMessage)
	}
	if m.FieldCleared(analysisjob.FieldStartedAt) {
		fields = append(fields, analysisjob.FieldStartedAt)
	}
	if m.FieldCleared(analysisjob.FieldFinishedAt) {
		fields = append(fields, analysisjob.FieldFinishedAt)
	}
	if m.FieldCleared(analysisjob.FieldEntryID) {
		fields = append(fields, analysisjob.FieldEntryID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AnalysisJobMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AnalysisJobMutation) ClearField(name string) error {
	switch name {
	case analysisjob.FieldProgress:
		m.ClearProgress()
		return nil
	case analysisjob.FieldResult:
		m.ClearResult()
		return nil
	case analysisjob.FieldMetrics:
		m.ClearMetrics()
		return nil
	case analysisjob.FieldErrorMessage:
		m.ClearErrorMessage()
		return nil
	case analysisjob.FieldStartedAt:
		m.ClearStartedAt()
		return nil
	case analysisjob.FieldFinishedAt:
		m.ClearFinishedAt()
		return nil
	case analysisjob.FieldEntryID:
		m.ClearEntryID()
		return nil
	}
	return fmt.Errorf("unknown AnalysisJob nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AnalysisJobMutation) ResetField(name string) error {
	switch name {
	case analysisjob.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case analysisjob.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case analysisjob.FieldPatientID:
		m.ResetPatientID()
		return nil
	case analysisjob.FieldCreatedByDoctorID:
		m.ResetCreatedByDoctorID()
		return nil
	case analysisjob.FieldObjectKey:
		m.ResetObjectKey()
		return nil
	case analysisjob.FieldKind:
		m.ResetKind()
		return nil
	case analysisjob.FieldStatus:
		m.ResetStatus()
		return nil
	case analysisjob.FieldProgress:
		m.ResetProgress()
		return nil
	case analysisjob.FieldResult:
		m.ResetResult()
		return nil
	case analysisjob.FieldMetrics:
		m.ResetMetrics()
		return nil
	case analysisjob.FieldErrorMessage:
		m.ResetErrorMessage()
		return nil
	case analysisjob.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case analysisjob.FieldFinishedAt:
		m.ResetFinishedAt()
		return nil
	case analysisjob.FieldEntryID:
		m.ResetEntryID()
		return nil
	}
	return fmt.Errorf("unknown AnalysisJob field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AnalysisJobMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.patient != nil {
		edges = append(edges, analysisjob.EdgePatient)
	}
	if m.created_by_doctor != nil {
		edges = append(edges, analysisjob.EdgeCreatedByDoctor)
	}
	if m.entry != nil {
		edges = append(edges, analysisjob.EdgeEntry)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AnalysisJobMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case analysisjob.EdgePatient:
		if id := m.patient; id != nil {
			return []ent.Value{*id}
		}
	case analysisjob.EdgeCreatedByDoctor:
		if id := m.created_by_doctor; id != nil {
			return []ent.Value{*id}
		}
	case analysisjob.EdgeEntry:
		if id := m.entry; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AnalysisJobMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AnalysisJobMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AnalysisJobMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedpatient {
		edges = append(edges, analysisjob.EdgePatient)
	}
	if m.clearedcreated_by_doctor {
		edges = append(edges, analysisjob.EdgeCreatedByDoctor)
	}
	if m.clearedentry {
		edges = append(edges, analysisjob.EdgeEntry)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AnalysisJobMutation) EdgeCleared(name string) bool {
	switch name {
	case analysisjob.EdgePatient:
		return m.clearedpatient
	case analysisjob.EdgeCreatedByDoctor:
		return m.clearedcreated_by_doctor
	case analysisjob.EdgeEntry:
		return m.clearedentry
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AnalysisJobMutation) ClearEdge(name string) error {
	switch name {
	case analysisjob.EdgePatient:
		m.ClearPatient()
		return nil
	case analysisjob.EdgeCreatedByDoctor:
		m.ClearCreatedByDoctor()
		return nil
	case analysisjob.EdgeEntry:
		m.ClearEntry()
		return nil
	}
	return fmt.Errorf("unknown AnalysisJob unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AnalysisJobMutation) ResetEdge(name string) error {
	switch name {
	case analysisjob.EdgePatient:
		m.ResetPatient()
		return nil
	case analysisjob.EdgeCreatedByDoctor:
		m.ResetCreatedByDoctor()
		return nil
	case analysisjob.EdgeEntry:
		m.ResetEntry()
		return nil
	}
	return fmt.Errorf("unknown AnalysisJob edge %s", name)
}

// CommentMutation represents an operation that mutates the Comment nodes in the graph.
type CommentMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	body          *string
	created_at    *time.Time
	clearedFields map[string]struct{}
	entry         *uuid.UUID
	clearedentry  bool
	author        *uuid.UUID
	clearedauthor bool
	done          bool
	oldValue      func(context.Context) (*Comment, error)
	predicates    []predicate.Comment
}

var _ ent.Mutation = (*CommentMutation)(nil)

// commentOption allows management of the mutation configuration using functional options.
type commentOption func(*CommentMutation)

// newCommentMutation creates new mutation for the Comment entity.
func newCommentMutation(c config, op Op, opts ...commentOption) *CommentMutation {
	m := &CommentMutation{
		config:        c,
		op:            op,
		typ:           TypeComment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCommentID sets the ID field of the mutation.
func withCommentID(id uuid.UUID) commentOption {
	return func(m *CommentMutation) {
		var (
			err   error
			once  sync.Once
			value *Comment
		)
		m.oldValue = func(ctx context.Context) (*Comment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Comment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withComment sets the old Comment of the mutation.
func withComment(node *Comment) commentOption {
	return func(m *CommentMutation) {
		m.oldValue = func(context.Context) (*Comment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CommentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CommentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Comment entities.
func (m *CommentMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CommentMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CommentMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Comment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEntryID sets the "entry_id" field.
func (m *CommentMutation) SetEntryID(u uuid.UUID) {
	m.entry = &u
}

// EntryID returns the value of the "entry_id" field in the mutation.
func (m *CommentMutation) EntryID() (r uuid.UUID, exists bool) {
	v := m.entry
	if v == nil {
		return
	}
	return *v, true
}

// OldEntryID returns the old "entry_id" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldEntryID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntryID: %w", err)
	}
	return oldValue.EntryID, nil
}

// ResetEntryID resets all changes to the "entry_id" field.
func (m *CommentMutation) ResetEntryID() {
	m.entry = nil
}

// SetAuthorDoctorID sets the "author_doctor_id" field.
func (m *CommentMutation) SetAuthorDoctorID(u uuid.UUID) {
	m.author = &u
}

// AuthorDoctorID returns the value of the "author_doctor_id" field in the mutation.
func (m *CommentMutation) AuthorDoctorID() (r uuid.UUID, exists bool) {
	v := m.author
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthorDoctorID returns the old "author_doctor_id" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldAuthorDoctorID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthorDoctorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthorDoctorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthorDoctorID: %w", err)
	}
	return oldValue.AuthorDoctorID, nil
}

// ResetAuthorDoctorID resets all changes to the "author_doctor_id" field.
func (m *CommentMutation) ResetAuthorDoctorID() {
	m.author = nil
}

// SetBody sets the "body" field.
func (m *CommentMutation) SetBody(s string) {
	m.body = &s
}

// Body returns the value of the "body" field in the mutation.
func (m *CommentMutation) Body() (r string, exists bool) {
	v := m.body
	if v == nil {
		return
	}
	return *v, true
}

// OldBody returns the old "body" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldBody(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBody is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBody requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBody: %w", err)
	}
	return oldValue.Body, nil
}

// ResetBody resets all changes to the "body" field.
func (m *CommentMutation) ResetBody() {
	m.body = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CommentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CommentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CommentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearEntry clears the "entry" edge to the Entry entity.
func (m *CommentMutation) ClearEntry() {
	m.clearedentry = true
	m.clearedFields[comment.FieldEntryID] = struct{}{}
}

// EntryCleared reports if the "entry" edge to the Entry entity was cleared.
func (m *CommentMutation) EntryCleared() bool {
	return m.clearedentry
}

// EntryIDs returns the "entry" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EntryID instead. It exists only for internal usage by the builders.
func (m *CommentMutation) EntryIDs() (ids []uuid.UUID) {
	if id := m.entry; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEntry resets all changes to the "entry" edge.
func (m *CommentMutation) ResetEntry() {
	m.entry = nil
	m.clearedentry = false
}

// SetAuthorID sets the "author" edge to the Doctor entity by id.
func (m *CommentMutation) SetAuthorID(id uuid.UUID) {
	m.author = &id
}

// ClearAuthor clears the "author" edge to the Doctor entity.
func (m *CommentMutation) ClearAuthor() {
	m.clearedauthor = true
	m.clearedFields[comment.FieldAuthorDoctorID] = struct{}{}
}

// AuthorCleared reports if the "author" edge to the Doctor entity was cleared.
func (m *CommentMutation) AuthorCleared() bool {
	return m.clearedauthor
}

// AuthorID returns the "author" edge ID in the mutation.
func (m *CommentMutation) AuthorID() (id uuid.UUID, exists bool) {
	if m.author != nil {
		return *m.author, true
	}
	return
}

// AuthorIDs returns the "author" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AuthorID instead. It exists only for internal usage by the builders.
func (m *CommentMutation) AuthorIDs() (ids []uuid.UUID) {
	if id := m.author; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAuthor resets all changes to the "author" edge.
func (m *CommentMutation) ResetAuthor() {
	m.author = nil
	m.clearedauthor = false
}

// Where appends a list predicates to the CommentMutation builder.
func (m *CommentMutation) Where(ps ...predicate.Comment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CommentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CommentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Comment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CommentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CommentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Comment).
func (m *CommentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CommentMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.entry != nil {
		fields = append(fields, comment.FieldEntryID)
	}
	if m.author != nil {
		fields = append(fields, comment.FieldAuthorDoctorID)
	}
	if m.body != nil {
		fields = append(fields, comment.FieldBody)
	}
	if m.created_at != nil {
		fields = append(fields, comment.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CommentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case comment.FieldEntryID:
		return m.EntryID()
	case comment.FieldAuthorDoctorID:
		return m.AuthorDoctorID()
	case comment.FieldBody:
		return m.Body()
	case comment.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CommentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case comment.FieldEntryID:
		return m.OldEntryID(ctx)
	case comment.FieldAuthorDoctorID:
		return m.OldAuthorDoctorID(ctx)
	case comment.FieldBody:
		return m.OldBody(ctx)
	case comment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Comment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case comment.FieldEntryID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntryID(v)
		return nil
	case comment.FieldAuthorDoctorID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthorDoctorID(v)
		return nil
	case comment.FieldBody:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBody(v)
		return nil
	case comment.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Comment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CommentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CommentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Comment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CommentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CommentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CommentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Comment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CommentMutation) ResetField(name string) error {
	switch name {
	case comment.FieldEntryID:
		m.ResetEntryID()
		return nil
	case comment.FieldAuthorDoctorID:
		m.ResetAuthorDoctorID()
		return nil
	case comment.FieldBody:
		m.ResetBody()
		return nil
	case comment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Comment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CommentMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.entry != nil {
		edges = append(edges, comment.EdgeEntry)
	}
	if m.author != nil {
		edges = append(edges, comment.EdgeAuthor)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CommentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case comment.EdgeEntry:
		if id := m.entry; id != nil {
			return []ent.Value{*id}
		}
	case comment.EdgeAuthor:
		if id := m.author; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CommentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CommentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CommentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedentry {
		edges = append(edges, comment.EdgeEntry)
	}
	if m.clearedauthor {
		edges = append(edges, comment.EdgeAuthor)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CommentMutation) EdgeCleared(name string) bool {
	switch name {
	case comment.EdgeEntry:
		return m.clearedentry
	case comment.EdgeAuthor:
		return m.clearedauthor
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CommentMutation) ClearEdge(name string) error {
	switch name {
	case comment.EdgeEntry:
		m.ClearEntry()
		return nil
	case comment.EdgeAuthor:
		m.ClearAuthor()
		return nil
	}
	return fmt.Errorf("unknown Comment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CommentMutation) ResetEdge(name string) error {
	switch name {
	case comment.EdgeEntry:
		m.ResetEntry()
		return nil
	case comment.EdgeAuthor:
		m.ResetAuthor()
		return nil
	}
	return fmt.Errorf("unknown Comment edge %s", name)
}

// DoctorMutation represents an operation that mutates the Doctor nodes in the graph.
type DoctorMutation struct {
	config
	op                            Op
	typ                           string
	id                            *uuid.UUID
	created_at                    *time.Time
	updated_at                    *time.Time
	email                         *string
	display_name                  *string
	password_hash                 *string
	role                          *doctor.Role
	clearedFields                 map[string]struct{}
	practice                      *uuid.UUID
	clearedpractice               bool
	patient_links                 map[uuid.UUID]struct{}
	removedpatient_links          map[uuid.UUID]struct{}
	clearedpatient_links          bool
	pairing_codes                 map[uuid.UUID]struct{}
	removedpairing_codes          map[uuid.UUID]struct{}
	clearedpairing_codes          bool
	approved_patient_links        map[uuid.UUID]struct{}
	removedapproved_patient_links map[uuid.UUID]struct{}
	clearedapproved_patient_links bool
	entry_shares                  map[uuid.UUID]struct{}
	removedentry_shares           map[uuid.UUID]struct{}
	clearedentry_shares           bool
	comments                      map[uuid.UUID]struct{}
	removedcomments               map[uuid.UUID]struct{}
	clearedcomments               bool
	created_analysis_jobs         map[uuid.UUID]struct{}
	removedcreated_analysis_jobs  map[uuid.UUID]struct{}
	clearedcreated_analysis_jobs  bool
	done                          bool
	oldValue                      func(context.Context) (*Doctor, error)
	predicates                    []predicate.Doctor
}

var _ ent.Mutation = (*DoctorMutation)(nil)

// doctorOption allows management of the mutation configuration using functional options.
type doctorOption func(*DoctorMutation)

// newDoctorMutation creates new mutation for the Doctor entity.
func newDoctorMutation(c config, op Op, opts ...doctorOption) *DoctorMutation {
	m := &DoctorMutation{
		config:        c,
		op:            op,
		typ:           TypeDoctor,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDoctorID sets the ID field of the mutation.
func withDoctorID(id uuid.UUID) doctorOption {
	return func(m *DoctorMutation) {
		var (
			err   error
			once  sync.Once
			value *Doctor
		)
		m.oldValue = func(ctx context.Context) (*Doctor, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Doctor.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDoctor sets the old Doctor of the mutation.
func withDoctor(node *Doctor) doctorOption {
	return func(m *DoctorMutation) {
		m.oldValue = func(context.Context) (*Doctor, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DoctorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DoctorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Doctor entities.
func (m *DoctorMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DoctorMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DoctorMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Doctor.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *DoctorMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DoctorMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Doctor entity.
// If the Doctor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DoctorMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DoctorMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DoctorMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DoctorMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Doctor entity.
// If the Doctor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DoctorMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DoctorMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetEmail sets the "email" field.
func (m *DoctorMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *DoctorMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Doctor entity.
// If the Doctor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DoctorMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *DoctorMutation) ResetEmail() {
	m.email = nil
}

// SetDisplayName sets the "display_name" field.
func (m *DoctorMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *DoctorMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the Doctor entity.
// If the Doctor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DoctorMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *DoctorMutation) ResetDisplayName() {
	m.display_name = nil
}

// SetPasswordHash sets the "password_hash" field.
func (m *DoctorMutation) SetPasswordHash(s string) {
	m.password_hash = &s
}

// PasswordHash returns the value of the "password_hash" field in the mutation.
func (m *DoctorMutation) PasswordHash() (r string, exists bool) {
	v := m.password_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordHash returns the old "password_hash" field's value of the Doctor entity.
// If the Doctor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DoctorMutation) OldPasswordHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordHash: %w", err)
	}
	return oldValue.PasswordHash, nil
}

// ResetPasswordHash resets all changes to the "password_hash" field.
func (m *DoctorMutation) ResetPasswordHash() {
	m.password_hash = nil
}

// SetRole sets the "role" field.
func (m *DoctorMutation) SetRole(d doctor.Role) {
	m.role = &d
}

// Role returns the value of the "role" field in the mutation.
func (m *DoctorMutation) Role() (r doctor.Role, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the Doctor entity.
// If the Doctor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DoctorMutation) OldRole(ctx context.Context) (v doctor.Role, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *DoctorMutation) ResetRole() {
	m.role = nil
}

// SetPracticeID sets the "practice_id" field.
func (m *DoctorMutation) SetPracticeID(u uuid.UUID) {
	m.practice = &u
}

// PracticeID returns the value of the "practice_id" field in the mutation.
func (m *DoctorMutation) PracticeID() (r uuid.UUID, exists bool) {
	v := m.practice
	if v == nil {
		return
	}
	return *v, true
}

// OldPracticeID returns the old "practice_id" field's value of the Doctor entity.
// If the Doctor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DoctorMutation) OldPracticeID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPracticeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPracticeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPracticeID: %w", err)
	}
	return oldValue.PracticeID, nil
}

// ClearPracticeID clears the value of the "practice_id" field.
func (m *DoctorMutation) ClearPracticeID() {
	m.practice = nil
	m.clearedFields[doctor.FieldPracticeID] = struct{}{}
}

// PracticeIDCleared returns if the "practice_id" field was cleared in this mutation.
func (m *DoctorMutation) PracticeIDCleared() bool {
	_, ok := m.clearedFields[doctor.FieldPracticeID]
	return ok
}

// ResetPracticeID resets all changes to the "practice_id" field.
func (m *DoctorMutation) ResetPracticeID() {
	m.practice = nil
	delete(m.clearedFields, doctor.FieldPracticeID)
}

// ClearPractice clears the "practice" edge to the Practice entity.
func (m *DoctorMutation) ClearPractice() {
	m.clearedpractice = true
	m.clearedFields[doctor.FieldPracticeID] = struct{}{}
}

// PracticeCleared reports if the "practice" edge to the Practice entity was cleared.
func (m *DoctorMutation) PracticeCleared() bool {
	return m.PracticeIDCleared() || m.clearedpractice
}

// PracticeIDs returns the "practice" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PracticeID instead. It exists only for internal usage by the builders.
func (m *DoctorMutation) PracticeIDs() (ids []uuid.UUID) {
	if id := m.practice; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPractice resets all changes to the "practice" edge.
func (m *DoctorMutation) ResetPractice() {
	m.practice = nil
	m.clearedpractice = false
}

// AddPatientLinkIDs adds the "patient_links" edge to the DoctorPatientLink entity by ids.
func (m *DoctorMutation) AddPatientLinkIDs(ids ...uuid.UUID) {
	if m.patient_links == nil {
		m.patient_links = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.patient_links[ids[i]] = struct{}{}
	}
}

// ClearPatientLinks clears the "patient_links" edge to the DoctorPatientLink entity.
func (m *DoctorMutation) ClearPatientLinks() {
	m.clearedpatient_links = true
}

// PatientLinksCleared reports if the "patient_links" edge to the DoctorPatientLink entity was cleared.
func (m *DoctorMutation) PatientLinksCleared() bool {
	return m.clearedpatient_links
}

// RemovePatientLinkIDs removes the "patient_links" edge to the DoctorPatientLink entity by IDs.
func (m *DoctorMutation) RemovePatientLinkIDs(ids ...uuid.UUID) {
	if m.removedpatient_links == nil {
		m.removedpatient_links = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.patient_links, ids[i])
		m.removedpatient_links[ids[i]] = struct{}{}
	}
}

// RemovedPatientLinks returns the removed IDs of the "patient_links" edge to the DoctorPatientLink entity.
func (m *DoctorMutation) RemovedPatientLinksIDs() (ids []uuid.UUID) {
	for id := range m.removedpatient_links {
		ids = append(ids, id)
	}
	return
}

// PatientLinksIDs returns the "patient_links" edge IDs in the mutation.
func (m *DoctorMutation) PatientLinksIDs() (ids []uuid.UUID) {
	for id := range m.patient_links {
		ids = append(ids, id)
	}
	return
}

// ResetPatientLinks resets all changes to the "patient_links" edge.
func (m *DoctorMutation) ResetPatientLinks() {
	m.patient_links = nil
	m.clearedpatient_links = false
	m.removedpatient_links = nil
}

// AddPairingCodeIDs adds the "pairing_codes" edge to the PairingCode entity by ids.
func (m *DoctorMutation) AddPairingCodeIDs(ids ...uuid.UUID) {
	if m.pairing_codes == nil {
		m.pairing_codes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.pairing_codes[ids[i]] = struct{}{}
	}
}

// ClearPairingCodes clears the "pairing_codes" edge to the PairingCode entity.
func (m *DoctorMutation) ClearPairingCodes() {
	m.clearedpairing_codes = true
}

// PairingCodesCleared reports if the "pairing_codes" edge to the PairingCode entity was cleared.
func (m *DoctorMutation) PairingCodesCleared() bool {
	return m.clearedpairing_codes
}

// RemovePairingCodeIDs removes the "pairing_codes" edge to the PairingCode entity by IDs.
func (m *DoctorMutation) RemovePairingCodeIDs(ids ...uuid.UUID) {
	if m.removedpairing_codes == nil {
		m.removedpairing_codes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.pairing_codes, ids[i])
		m.removedpairing_codes[ids[i]] = struct{}{}
	}
}

// RemovedPairingCodes returns the removed IDs of the "pairing_codes" edge to the PairingCode entity.
func (m *DoctorMutation) RemovedPairingCodesIDs() (ids []uuid.UUID) {
	for id := range m.removedpairing_codes {
		ids = append(ids, id)
	}
	return
}

// PairingCodesIDs returns the "pairing_codes" edge IDs in the mutation.
func (m *DoctorMutation) PairingCodesIDs() (ids []uuid.UUID) {
	for id := range m.pairing_codes {
		ids = append(ids, id)
	}
	return
}

// ResetPairingCodes resets all changes to the "pairing_codes" edge.
func (m *DoctorMutation) ResetPairingCodes() {
	m.pairing_codes = nil
	m.clearedpairing_codes = false
	m.removedpairing_codes = nil
}

// AddApprovedPatientLinkIDs adds the "approved_patient_links" edge to the DoctorPatientLink entity by ids.
func (m *DoctorMutation) AddApprovedPatientLinkIDs(ids ...uuid.UUID) {
	if m.approved_patient_links == nil {
		m.approved_patient_links = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.approved_patient_links[ids[i]] = struct{}{}
	}
}

// ClearApprovedPatientLinks clears the "approved_patient_links" edge to the DoctorPatientLink entity.
func (m *DoctorMutation) ClearApprovedPatientLinks() {
	m.clearedapproved_patient_links = true
}

// ApprovedPatientLinksCleared reports if the "approved_patient_links" edge to the DoctorPatientLink entity was cleared.
func (m *DoctorMutation) ApprovedPatientLinksCleared() bool {
	return m.clearedapproved_patient_links
}

// RemoveApprovedPatientLinkIDs removes the "approved_patient_links" edge to the DoctorPatientLink entity by IDs.
func (m *DoctorMutation) RemoveApprovedPatientLinkIDs(ids ...uuid.UUID) {
	if m.removedapproved_patient_links == nil {
		m.removedapproved_patient_links = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.approved_patient_links, ids[i])
		m.removedapproved_patient_links[ids[i]] = struct{}{}
	}
}

// RemovedApprovedPatientLinks returns the removed IDs of the "approved_patient_links" edge to the DoctorPatientLink entity.
func (m *DoctorMutation) RemovedApprovedPatientLinksIDs() (ids []uuid.UUID) {
	for id := range m.removedapproved_patient_links {
		ids = append(ids, id)
	}
	return
}

// ApprovedPatientLinksIDs returns the "approved_patient_links" edge IDs in the mutation.
func (m *DoctorMutation) ApprovedPatientLinksIDs() (ids []uuid.UUID) {
	for id := range m.approved_patient_links {
		ids = append(ids, id)
	}
	return
}

// ResetApprovedPatientLinks resets all changes to the "approved_patient_links" edge.
func (m *DoctorMutation) ResetApprovedPatientLinks() {
	m.approved_patient_links = nil
	m.clearedapproved_patient_links = false
	m.removedapproved_patient_links = nil
}

// AddEntryShareIDs adds the "entry_shares" edge to the EntryShare entity by ids.
func (m *DoctorMutation) AddEntryShareIDs(ids ...uuid.UUID) {
	if m.entry_shares == nil {
		m.entry_shares = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.entry_shares[ids[i]] = struct{}{}
	}
}

// ClearEntryShares clears the "entry_shares" edge to the EntryShare entity.
func (m *DoctorMutation) ClearEntryShares() {
	m.clearedentry_shares = true
}

// EntrySharesCleared reports if the "entry_shares" edge to the EntryShare entity was cleared.
func (m *DoctorMutation) EntrySharesCleared() bool {
	return m.clearedentry_shares
}

// RemoveEntryShareIDs removes the "entry_shares" edge to the EntryShare entity by IDs.
func (m *DoctorMutation) RemoveEntryShareIDs(ids ...uuid.UUID) {
	if m.removedentry_shares == nil {
		m.removedentry_shares = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.entry_shares, ids[i])
		m.removedentry_shares[ids[i]] = struct{}{}
	}
}

// RemovedEntryShares returns the removed IDs of the "entry_shares" edge to the EntryShare entity.
func (m *DoctorMutation) RemovedEntrySharesIDs() (ids []uuid.UUID) {
	for id := range m.removedentry_shares {
		ids = append(ids, id)
	}
	return
}

// EntrySharesIDs returns the "entry_shares" edge IDs in the mutation.
func (m *DoctorMutation) EntrySharesIDs() (ids []uuid.UUID) {
	for id := range m.entry_shares {
		ids = append(ids, id)
	}
	return
}

// ResetEntryShares resets all changes to the "entry_shares" edge.
func (m *DoctorMutation) ResetEntryShares() {
	m.entry_shares = nil
	m.clearedentry_shares = false
	m.removedentry_shares = nil
}

// AddCommentIDs adds the "comments" edge to the Comment entity by ids.
func (m *DoctorMutation) AddCommentIDs(ids ...uuid.UUID) {
	if m.comments == nil {
		m.comments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.comments[ids[i]] = struct{}{}
	}
}

// ClearComments clears the "comments" edge to the Comment entity.
func (m *DoctorMutation) ClearComments() {
	m.clearedcomments = true
}

// CommentsCleared reports if the "comments" edge to the Comment entity was cleared.
func (m *DoctorMutation) CommentsCleared() bool {
	return m.clearedcomments
}

// RemoveCommentIDs removes the "comments" edge to the Comment entity by IDs.
func (m *DoctorMutation) RemoveCommentIDs(ids ...uuid.UUID) {
	if m.removedcomments == nil {
		m.removedcomments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.comments, ids[i])
		m.removedcomments[ids[i]] = struct{}{}
	}
}

// RemovedComments returns the removed IDs of the "comments" edge to the Comment entity.
func (m *DoctorMutation) RemovedCommentsIDs() (ids []uuid.UUID) {
	for id := range m.removedcomments {
		ids = append(ids, id)
	}
	return
}

// CommentsIDs returns the "comments" edge IDs in the mutation.
func (m *DoctorMutation) CommentsIDs() (ids []uuid.UUID) {
	for id := range m.comments {
		ids = append(ids, id)
	}
	return
}

// ResetComments resets all changes to the "comments" edge.
func (m *DoctorMutation) ResetComments() {
	m.comments = nil
	m.clearedcomments = false
	m.removedcomments = nil
}

// AddCreatedAnalysisJobIDs adds the "created_analysis_jobs" edge to the AnalysisJob entity by ids.
func (m *DoctorMutation) AddCreatedAnalysisJobIDs(ids ...uuid.UUID) {
	if m.created_analysis_jobs == nil {
		m.created_analysis_jobs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.created_analysis_jobs[ids[i]] = struct{}{}
	}
}

// ClearCreatedAnalysisJobs clears the "created_analysis_jobs" edge to the AnalysisJob entity.
func (m *DoctorMutation) ClearCreatedAnalysisJobs() {
	m.clearedcreated_analysis_jobs = true
}

// CreatedAnalysisJobsCleared reports if the "created_analysis_jobs" edge to the AnalysisJob entity was cleared.
func (m *DoctorMutation) CreatedAnalysisJobsCleared() bool {
	return m.clearedcreated_analysis_jobs
}

// RemoveCreatedAnalysisJobIDs removes the "created_analysis_jobs" edge to the AnalysisJob entity by IDs.
func (m *DoctorMutation) RemoveCreatedAnalysisJobIDs(ids ...uuid.UUID) {
	if m.removedcreated_analysis_jobs == nil {
		m.removedcreated_analysis_jobs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.created_analysis_jobs, ids[i])
		m.removedcreated_analysis_jobs[ids[i]] = struct{}{}
	}
}

// RemovedCreatedAnalysisJobs returns the removed IDs of the "created_analysis_jobs" edge to the AnalysisJob entity.
func (m *DoctorMutation) RemovedCreatedAnalysisJobsIDs() (ids []uuid.UUID) {
	for id := range m.removedcreated_analysis_jobs {
		ids = append(ids, id)
	}
	return
}

// CreatedAnalysisJobsIDs returns the "created_analysis_jobs" edge IDs in the mutation.
func (m *DoctorMutation) CreatedAnalysisJobsIDs() (ids []uuid.UUID) {
	for id := range m.created_analysis_jobs {
		ids = append(ids, id)
	}
	return
}

// ResetCreatedAnalysisJobs resets all changes to the "created_analysis_jobs" edge.
func (m *DoctorMutation) ResetCreatedAnalysisJobs() {
	m.created_analysis_jobs = nil
	m.clearedcreated_analysis_jobs = false
	m.removedcreated_analysis_jobs = nil
}

// Where appends a list predicates to the DoctorMutation builder.
func (m *DoctorMutation) Where(ps ...predicate.Doctor) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DoctorMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DoctorMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Doctor, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DoctorMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DoctorMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Doctor).
func (m *DoctorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DoctorMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, doctor.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, doctor.FieldUpdatedAt)
	}
	if m.email != nil {
		fields = append(fields, doctor.FieldEmail)
	}
	if m.display_name != nil {
		fields = append(fields, doctor.FieldDisplayName)
	}
	if m.password_hash != nil {
		fields = append(fields, doctor.FieldPasswordHash)
	}
	if m.role != nil {
		fields = append(fields, doctor.FieldRole)
	}
	if m.practice != nil {
		fields = append(fields, doctor.FieldPracticeID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DoctorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case doctor.FieldCreatedAt:
		return m.CreatedAt()
	case doctor.FieldUpdatedAt:
		return m.UpdatedAt()
	case doctor.FieldEmail:
		return m.Email()
	case doctor.FieldDisplayName:
		return m.DisplayName()
	case doctor.FieldPasswordHash:
		return m.PasswordHash()
	case doctor.FieldRole:
		return m.Role()
	case doctor.FieldPracticeID:
		return m.PracticeID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DoctorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case doctor.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case doctor.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case doctor.FieldEmail:
		return m.OldEmail(ctx)
	case doctor.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case doctor.FieldPasswordHash:
		return m.OldPasswordHash(ctx)
	case doctor.FieldRole:
		return m.OldRole(ctx)
	case doctor.FieldPracticeID:
		return m.OldPracticeID(ctx)
	}
	return nil, fmt.Errorf("unknown Doctor field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DoctorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case doctor.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case doctor.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case doctor.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case doctor.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case doctor.FieldPasswordHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordHash(v)
		return nil
	case doctor.FieldRole:
		v, ok := value.(doctor.Role)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case doctor.FieldPracticeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPracticeID(v)
		return nil
	}
	return fmt.Errorf("unknown Doctor field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DoctorMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DoctorMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DoctorMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Doctor numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DoctorMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(doctor.FieldPracticeID) {
		fields = append(fields, doctor.FieldPracticeID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DoctorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DoctorMutation) ClearField(name string) error {
	switch name {
	case doctor.FieldPracticeID:
		m.ClearPracticeID()
		return nil
	}
	return fmt.Errorf("unknown Doctor nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DoctorMutation) ResetField(name string) error {
	switch name {
	case doctor.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case doctor.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case doctor.FieldEmail:
		m.ResetEmail()
		return nil
	case doctor.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case doctor.FieldPasswordHash:
		m.ResetPasswordHash()
		return nil
	case doctor.FieldRole:
		m.ResetRole()
		return nil
	case doctor.FieldPracticeID:
		m.ResetPracticeID()
		return nil
	}
	return fmt.Errorf("unknown Doctor field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DoctorMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.practice != nil {
		edges = append(edges, doctor.EdgePractice)
	}
	if m.patient_links != nil {
		edges = append(edges, doctor.EdgePatientLinks)
	}
	if m.pairing_codes != nil {
		edges = append(edges, doctor.EdgePairingCodes)
	}
	if m.approved_patient_links != nil {
		edges = append(edges, doctor.EdgeApprovedPatientLinks)
	}
	if m.entry_shares != nil {
		edges = append(edges, doctor.EdgeEntryShares)
	}
	if m.comments != nil {
		edges = append(edges, doctor.EdgeComments)
	}
	if m.created_analysis_jobs != nil {
		edges = append(edges, doctor.EdgeCreatedAnalysisJobs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DoctorMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case doctor.EdgePractice:
		if id := m.practice; id != nil {
			return []ent.Value{*id}
		}
	case doctor.EdgePatientLinks:
		ids := make([]ent.Value, 0, len(m.patient_links))
		for id := range m.patient_links {
			ids = append(ids, id)
		}
		return ids
	case doctor.EdgePairingCodes:
		ids := make([]ent.Value, 0, len(m.pairing_codes))
		for id := range m.pairing_codes {
			ids = append(ids, id)
		}
		return ids
	case doctor.EdgeApprovedPatientLinks:
		ids := make([]ent.Value, 0, len(m.approved_patient_links))
		for id := range m.approved_patient_links {
			ids = append(ids, id)
		}
		return ids
	case doctor.EdgeEntryShares:
		ids := make([]ent.Value, 0, len(m.entry_shares))
		for id := range m.entry_shares {
			ids = append(ids, id)
		}
		return ids
	case doctor.EdgeComments:
		ids := make([]ent.Value, 0, len(m.comments))
		for id := range m.comments {
			ids = append(ids, id)
		}
		return ids
	case doctor.EdgeCreatedAnalysisJobs:
		ids := make([]ent.Value, 0, len(m.created_analysis_jobs))
		for id := range m.created_analysis_jobs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DoctorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedpatient_links != nil {
		edges = append(edges, doctor.EdgePatientLinks)
	}
	if m.removedpairing_codes != nil {
		edges = append(edges, doctor.EdgePairingCodes)
	}
	if m.removedapproved_patient_links != nil {
		edges = append(edges, doctor.EdgeApprovedPatientLinks)
	}
	if m.removedentry_shares != nil {
		edges = append(edges, doctor.EdgeEntryShares)
	}
	if m.removedcomments != nil {
		edges = append(edges, doctor.EdgeComments)
	}
	if m.removedcreated_analysis_jobs != nil {
		edges = append(edges, doctor.EdgeCreatedAnalysisJobs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DoctorMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case doctor.EdgePatientLinks:
		ids := make([]ent.Value, 0, len(m.removedpatient_links))
		for id := range m.removedpatient_links {
			ids = append(ids, id)
		}
		return ids
	case doctor.EdgePairingCodes:
		ids := make([]ent.Value, 0, len(m.removedpairing_codes))
		for id := range m.removedpairing_codes {
			ids = append(ids, id)
		}
		return ids
	case doctor.EdgeApprovedPatientLinks:
		ids := make([]ent.Value, 0, len(m.removedapproved_patient_links))
		for id := range m.removedapproved_patient_links {
			ids = append(ids, id)
		}
		return ids
	case doctor.EdgeEntryShares:
		ids := make([]ent.Value, 0, len(m.removedentry_shares))
		for id := range m.removedentry_shares {
			ids = append(ids, id)
		}
		return ids
	case doctor.EdgeComments:
		ids := make([]ent.Value, 0, len(m.removedcomments))
		for id := range m.removedcomments {
			ids = append(ids, id)
		}
		return ids
	case doctor.EdgeCreatedAnalysisJobs:
		ids := make([]ent.Value, 0, len(m.removedcreated_analysis_jobs))
		for id := range m.removedcreated_analysis_jobs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DoctorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedpractice {
		edges = append(edges, doctor.EdgePractice)
	}
	if m.clearedpatient_links {
		edges = append(edges, doctor.EdgePatientLinks)
	}
	if m.clearedpairing_codes {
		edges = append(edges, doctor.EdgePairingCodes)
	}
	if m.clearedapproved_patient_links {
		edges = append(edges, doctor.EdgeApprovedPatientLinks)
	}
	if m.clearedentry_shares {
		edges = append(edges, doctor.EdgeEntryShares)
	}
	if m.clearedcomments {
		edges = append(edges, doctor.EdgeComments)
	}
	if m.clearedcreated_analysis_jobs {
		edges = append(edges, doctor.EdgeCreatedAnalysisJobs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DoctorMutation) EdgeCleared(name string) bool {
	switch name {
	case doctor.EdgePractice:
		return m.clearedpractice
	case doctor.EdgePatientLinks:
		return m.clearedpatient_links
	case doctor.EdgePairingCodes:
		return m.clearedpairing_codes
	case doctor.EdgeApprovedPatientLinks:
		return m.clearedapproved_patient_links
	case doctor.EdgeEntryShares:
		return m.clearedentry_shares
	case doctor.EdgeComments:
		return m.clearedcomments
	case doctor.EdgeCreatedAnalysisJobs:
		return m.clearedcreated_analysis_jobs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DoctorMutation) ClearEdge(name string) error {
	switch name {
	case doctor.EdgePractice:
		m.ClearPractice()
		return nil
	}
	return fmt.Errorf("unknown Doctor unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DoctorMutation) ResetEdge(name string) error {
	switch name {
	case doctor.EdgePractice:
		m.ResetPractice()
		return nil
	case doctor.EdgePatientLinks:
		m.ResetPatientLinks()
		return nil
	case doctor.EdgePairingCodes:
		m.ResetPairingCodes()
		return nil
	case doctor.EdgeApprovedPatientLinks:
		m.ResetApprovedPatientLinks()
		return nil
	case doctor.EdgeEntryShares:
		m.ResetEntryShares()
		return nil
	case doctor.EdgeComments:
		m.ResetComments()
		return nil
	case doctor.EdgeCreatedAnalysisJobs:
		m.ResetCreatedAnalysisJobs()
		return nil
	}
	return fmt.Errorf("unknown Doctor edge %s", name)
}

// DoctorPatientLinkMutation represents an operation that mutates the DoctorPatientLink nodes in the graph.
type DoctorPatientLinkMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	created_at         *time.Time
	updated_at         *time.Time
	status             *doctorpatientlink.Status
	requested_at       *time.Time
	approved_at        *time.Time
	clearedFields      map[string]struct{}
	doctor             *uuid.UUID
	cleareddoctor      bool
	patient            *uuid.UUID
	clearedpatient     bool
	approved_by        *uuid.UUID
	clearedapproved_by bool
	done               bool
	oldValue           func(context.Context) (*DoctorPatientLink, error)
	predicates         []predicate.DoctorPatientLink
}

var _ ent.Mutation = (*DoctorPatientLinkMutation)(nil)

// doctorpatientlinkOption allows management of the mutation configuration using functional options.
type doctorpatientlinkOption func(*DoctorPatientLinkMutation)

// newDoctorPatientLinkMutation creates new mutation for the DoctorPatientLink entity.
func newDoctorPatientLinkMutation(c config, op Op, opts ...doctorpatientlinkOption) *DoctorPatientLinkMutation {
	m := &DoctorPatientLinkMutation{
		config:        c,
		op:            op,
		typ:           TypeDoctorPatientLink,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDoctorPatientLinkID sets the ID field of the mutation.
func withDoctorPatientLinkID(id uuid.UUID) doctorpatientlinkOption {
	return func(m *DoctorPatientLinkMutation) {
		var (
			err   error
			once  sync.Once
			value *DoctorPatientLink
		)
		m.oldValue = func(ctx context.Context) (*DoctorPatientLink, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DoctorPatientLink.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDoctorPatientLink sets the old DoctorPatientLink of the mutation.
func withDoctorPatientLink(node *DoctorPatientLink) doctorpatientlinkOption {
	return func(m *DoctorPatientLinkMutation) {
		m.oldValue = func(context.Context) (*DoctorPatientLink, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DoctorPatientLinkMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DoctorPatientLinkMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DoctorPatientLink entities.
func (m *DoctorPatientLinkMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DoctorPatientLinkMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DoctorPatientLinkMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DoctorPatientLink.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *DoctorPatientLinkMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DoctorPatientLinkMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DoctorPatientLink entity.
// If the DoctorPatientLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DoctorPatientLinkMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DoctorPatientLinkMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DoctorPatientLinkMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DoctorPatientLinkMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DoctorPatientLink entity.
// If the DoctorPatientLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DoctorPatientLinkMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DoctorPatientLinkMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDoctorID sets the "doctor_id" field.
func (m *DoctorPatientLinkMutation) SetDoctorID(u uuid.UUID) {
	m.doctor = &u
}

// DoctorID returns the value of the "doctor_id" field in the mutation.
func (m *DoctorPatientLinkMutation) DoctorID() (r uuid.UUID, exists bool) {
	v := m.doctor
	if v == nil {
		return
	}
	return *v, true
}

// OldDoctorID returns the old "doctor_id" field's value of the DoctorPatientLink entity.
// If the DoctorPatientLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DoctorPatientLinkMutation) OldDoctorID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDoctorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDoctorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDoctorID: %w", err)
	}
	return oldValue.DoctorID, nil
}

// ResetDoctorID resets all changes to the "doctor_id" field.
func (m *DoctorPatientLinkMutation) ResetDoctorID() {
	m.doctor = nil
}

// SetPatientID sets the "patient_id" field.
func (m *DoctorPatientLinkMutation) SetPatientID(u uuid.UUID) {
	m.patient = &u
}

// PatientID returns the value of the "patient_id" field in the mutation.
func (m *DoctorPatientLinkMutation) PatientID() (r uuid.UUID, exists bool) {
	v := m.patient
	if v == nil {
		return
	}
	return *v, true
}

// OldPatientID returns the old "patient_id" field's value of the DoctorPatientLink entity.
// If the DoctorPatientLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DoctorPatientLinkMutation) OldPatientID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPatientID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPatientID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPatientID: %w", err)
	}
	return oldValue.PatientID, nil
}

// ResetPatientID resets all changes to the "patient_id" field.
func (m *DoctorPatientLinkMutation) ResetPatientID() {
	m.patient = nil
}

// SetStatus sets the "status" field.
func (m *DoctorPatientLinkMutation) SetStatus(d doctorpatientlink.Status) {
	m.status = &d
}

// Status returns the value of the "status" field in the mutation.
func (m *DoctorPatientLinkMutation) Status() (r doctorpatientlink.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the DoctorPatientLink entity.
// If the DoctorPatientLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DoctorPatientLinkMutation) OldStatus(ctx context.Context) (v doctorpatientlink.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *DoctorPatientLinkMutation) ResetStatus() {
	m.status = nil
}

// SetRequestedAt sets the "requested_at" field.
func (m *DoctorPatientLinkMutation) SetRequestedAt(t time.Time) {
	m.requested_at = &t
}

// RequestedAt returns the value of the "requested_at" field in the mutation.
func (m *DoctorPatientLinkMutation) RequestedAt() (r time.Time, exists bool) {
	v := m.requested_at
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestedAt returns the old "requested_at" field's value of the DoctorPatientLink entity.
// If the DoctorPatientLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DoctorPatientLinkMutation) OldRequestedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestedAt: %w", err)
	}
	return oldValue.RequestedAt, nil
}

// ResetRequestedAt resets all changes to the "requested_at" field.
func (m *DoctorPatientLinkMutation) ResetRequestedAt() {
	m.requested_at = nil
}

// SetApprovedAt sets the "approved_at" field.
func (m *DoctorPatientLinkMutation) SetApprovedAt(t time.Time) {
	m.approved_at = &t
}

// ApprovedAt returns the value of the "approved_at" field in the mutation.
func (m *DoctorPatientLinkMutation) ApprovedAt() (r time.Time, exists bool) {
	v := m.approved_at
	if v == nil {
		return
	}
	return *v, true
}

// OldApprovedAt returns the old "approved_at" field's value of the DoctorPatientLink entity.
// If the DoctorPatientLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DoctorPatientLinkMutation) OldApprovedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApprovedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApprovedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApprovedAt: %w", err)
	}
	return oldValue.ApprovedAt, nil
}

// ClearApprovedAt clears the value of the "approved_at" field.
func (m *DoctorPatientLinkMutation) ClearApprovedAt() {
	m.approved_at = nil
	m.clearedFields[doctorpatientlink.FieldApprovedAt] = struct{}{}
}

// ApprovedAtCleared returns if the "approved_at" field was cleared in this mutation.
func (m *DoctorPatientLinkMutation) ApprovedAtCleared() bool {
	_, ok := m.clearedFields[doctorpatientlink.FieldApprovedAt]
	return ok
}

// ResetApprovedAt resets all changes to the "approved_at" field.
func (m *DoctorPatientLinkMutation) ResetApprovedAt() {
	m.approved_at = nil
	delete(m.clearedFields, doctorpatientlink.FieldApprovedAt)
}

// SetApprovedByDoctorID sets the "approved_by_doctor_id" field.
func (m *DoctorPatientLinkMutation) SetApprovedByDoctorID(u uuid.UUID) {
	m.approved_by = &u
}

// ApprovedByDoctorID returns the value of the "approved_by_doctor_id" field in the mutation.
func (m *DoctorPatientLinkMutation) ApprovedByDoctorID() (r uuid.UUID, exists bool) {
	v := m.approved_by
	if v == nil {
		return
	}
	return *v, true
}

// OldApprovedByDoctorID returns the old "approved_by_doctor_id" field's value of the DoctorPatientLink entity.
// If the DoctorPatientLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DoctorPatientLinkMutation) OldApprovedByDoctorID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApprovedByDoctorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApprovedByDoctorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApprovedByDoctorID: %w", err)
	}
	return oldValue.ApprovedByDoctorID, nil
}

// ClearApprovedByDoctorID clears the value of the "approved_by_doctor_id" field.
func (m *DoctorPatientLinkMutation) ClearApprovedByDoctorID() {
	m.approved_by = nil
	m.clearedFields[doctorpatientlink.FieldApprovedByDoctorID] = struct{}{}
}

// ApprovedByDoctorIDCleared returns if the "approved_by_doctor_id" field was cleared in this mutation.
func (m *DoctorPatientLinkMutation) ApprovedByDoctorIDCleared() bool {
	_, ok := m.clearedFields[doctorpatientlink.FieldApprovedByDoctorID]
	return ok
}

// ResetApprovedByDoctorID resets all changes to the "approved_by_doctor_id" field.
func (m *DoctorPatientLinkMutation) ResetApprovedByDoctorID() {
	m.approved_by = nil
	delete(m.clearedFields, doctorpatientlink.FieldApprovedByDoctorID)
}

// ClearDoctor clears the "doctor" edge to the Doctor entity.
func (m *DoctorPatientLinkMutation) ClearDoctor() {
	m.cleareddoctor = true
	m.clearedFields[doctorpatientlink.FieldDoctorID] = struct{}{}
}

// DoctorCleared reports if the "doctor" edge to the Doctor entity was cleared.
func (m *DoctorPatientLinkMutation) DoctorCleared() bool {
	return m.cleareddoctor
}

// DoctorIDs returns the "doctor" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DoctorID instead. It exists only for internal usage by the builders.
func (m *DoctorPatientLinkMutation) DoctorIDs() (ids []uuid.UUID) {
	if id := m.doctor; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDoctor resets all changes to the "doctor" edge.
func (m *DoctorPatientLinkMutation) ResetDoctor() {
	m.doctor = nil
	m.cleareddoctor = false
}

// ClearPatient clears the "patient" edge to the Patient entity.
func (m *DoctorPatientLinkMutation) ClearPatient() {
	m.clearedpatient = true
	m.clearedFields[doctorpatientlink.FieldPatientID] = struct{}{}
}

// PatientCleared reports if the "patient" edge to the Patient entity was cleared.
func (m *DoctorPatientLinkMutation) PatientCleared() bool {
	return m.clearedpatient
}

// PatientIDs returns the "patient" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PatientID instead. It exists only for internal usage by the builders.
func (m *DoctorPatientLinkMutation) PatientIDs() (ids []uuid.UUID) {
	if id := m.patient; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPatient resets all changes to the "patient" edge.
func (m *DoctorPatientLinkMutation) ResetPatient() {
	m.patient = nil
	m.clearedpatient = false
}

// SetApprovedByID sets the "approved_by" edge to the Doctor entity by id.
func (m *DoctorPatientLinkMutation) SetApprovedByID(id uuid.UUID) {
	m.approved_by = &id
}

// ClearApprovedBy clears the "approved_by" edge to the Doctor entity.
func (m *DoctorPatientLinkMutation) ClearApprovedBy() {
	m.clearedapproved_by = true
	m.clearedFields[doctorpatientlink.FieldApprovedByDoctorID] = struct{}{}
}

// ApprovedByCleared reports if the "approved_by" edge to the Doctor entity was cleared.
func (m *DoctorPatientLinkMutation) ApprovedByCleared() bool {
	return m.ApprovedByDoctorIDCleared() || m.clearedapproved_by
}

// ApprovedByID returns the "approved_by" edge ID in the mutation.
func (m *DoctorPatientLinkMutation) ApprovedByID() (id uuid.UUID, exists bool) {
	if m.approved_by != nil {
		return *m.approved_by, true
	}
	return
}

// ApprovedByIDs returns the "approved_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ApprovedByID instead. It exists only for internal usage by the builders.
func (m *DoctorPatientLinkMutation) ApprovedByIDs() (ids []uuid.UUID) {
	if id := m.approved_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApprovedBy resets all changes to the "approved_by" edge.
func (m *DoctorPatientLinkMutation) ResetApprovedBy() {
	m.approved_by = nil
	m.clearedapproved_by = false
}

// Where appends a list predicates to the DoctorPatientLinkMutation builder.
func (m *DoctorPatientLinkMutation) Where(ps ...predicate.DoctorPatientLink) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DoctorPatientLinkMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DoctorPatientLinkMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DoctorPatientLink, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DoctorPatientLinkMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DoctorPatientLinkMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DoctorPatientLink).
func (m *DoctorPatientLinkMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DoctorPatientLinkMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, doctorpatientlink.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, doctorpatientlink.FieldUpdatedAt)
	}
	if m.doctor != nil {
		fields = append(fields, doctorpatientlink.FieldDoctorID)
	}
	if m.patient != nil {
		fields = append(fields, doctorpatientlink.FieldPatientID)
	}
	if m.status != nil {
		fields = append(fields, doctorpatientlink.FieldStatus)
	}
	if m.requested_at != nil {
		fields = append(fields, doctorpatientlink.FieldRequestedAt)
	}
	if m.approved_at != nil {
		fields = append(fields, doctorpatientlink.FieldApprovedAt)
	}
	if m.approved_by != nil {
		fields = append(fields, doctorpatientlink.FieldApprovedByDoctorID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DoctorPatientLinkMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case doctorpatientlink.FieldCreatedAt:
		return m.CreatedAt()
	case doctorpatientlink.FieldUpdatedAt:
		return m.UpdatedAt()
	case doctorpatientlink.FieldDoctorID:
		return m.DoctorID()
	case doctorpatientlink.FieldPatientID:
		return m.PatientID()
	case doctorpatientlink.FieldStatus:
		return m.Status()
	case doctorpatientlink.FieldRequestedAt:
		return m.RequestedAt()
	case doctorpatientlink.FieldApprovedAt:
		return m.ApprovedAt()
	case doctorpatientlink.FieldApprovedByDoctorID:
		return m.ApprovedByDoctorID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DoctorPatientLinkMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case doctorpatientlink.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case doctorpatientlink.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case doctorpatientlink.FieldDoctorID:
		return m.OldDoctorID(ctx)
	case doctorpatientlink.FieldPatientID:
		return m.OldPatientID(ctx)
	case doctorpatientlink.FieldStatus:
		return m.OldStatus(ctx)
	case doctorpatientlink.FieldRequestedAt:
		return m.OldRequestedAt(ctx)
	case doctorpatientlink.FieldApprovedAt:
		return m.OldApprovedAt(ctx)
	case doctorpatientlink.FieldApprovedByDoctorID:
		return m.OldApprovedByDoctorID(ctx)
	}
	return nil, fmt.Errorf("unknown DoctorPatientLink field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DoctorPatientLinkMutation) SetField(name string, value ent.Value) error {
	switch name {
	case doctorpatientlink.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case doctorpatientlink.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case doctorpatientlink.FieldDoctorID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDoctorID(v)
		return nil
	case doctorpatientlink.FieldPatientID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPatientID(v)
		return nil
	case doctorpatientlink.FieldStatus:
		v, ok := value.(doctorpatientlink.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case doctorpatientlink.FieldRequestedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestedAt(v)
		return nil
	case doctorpatientlink.FieldApprovedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApprovedAt(v)
		return nil
	case doctorpatientlink.FieldApprovedByDoctorID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApprovedByDoctorID(v)
		return nil
	}
	return fmt.Errorf("unknown DoctorPatientLink field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DoctorPatientLinkMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DoctorPatientLinkMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DoctorPatientLinkMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DoctorPatientLink numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DoctorPatientLinkMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(doctorpatientlink.FieldApprovedAt) {
		fields = append(fields, doctorpatientlink.FieldApprovedAt)
	}
	if m.FieldCleared(doctorpatientlink.FieldApprovedByDoctorID) {
		fields = append(fields, doctorpatientlink.FieldApprovedByDoctorID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DoctorPatientLinkMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DoctorPatientLinkMutation) ClearField(name string) error {
	switch name {
	case doctorpatientlink.FieldApprovedAt:
		m.ClearApprovedAt()
		return nil
	case doctorpatientlink.FieldApprovedByDoctorID:
		m.ClearApprovedByDoctorID()
		return nil
	}
	return fmt.Errorf("unknown DoctorPatientLink nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DoctorPatientLinkMutation) ResetField(name string) error {
	switch name {
	case doctorpatientlink.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case doctorpatientlink.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case doctorpatientlink.FieldDoctorID:
		m.ResetDoctorID()
		return nil
	case doctorpatientlink.FieldPatientID:
		m.ResetPatientID()
		return nil
	case doctorpatientlink.FieldStatus:
		m.ResetStatus()
		return nil
	case doctorpatientlink.FieldRequestedAt:
		m.ResetRequestedAt()
		return nil
	case doctorpatientlink.FieldApprovedAt:
		m.ResetApprovedAt()
		return nil
	case doctorpatientlink.FieldApprovedByDoctorID:
		m.ResetApprovedByDoctorID()
		return nil
	}
	return fmt.Errorf("unknown DoctorPatientLink field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DoctorPatientLinkMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.doctor != nil {
		edges = append(edges, doctorpatientlink.EdgeDoctor)
	}
	if m.patient != nil {
		edges = append(edges, doctorpatientlink.EdgePatient)
	}
	if m.approved_by != nil {
		edges = append(edges, doctorpatientlink.EdgeApprovedBy)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DoctorPatientLinkMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case doctorpatientlink.EdgeDoctor:
		if id := m.doctor; id != nil {
			return []ent.Value{*id}
		}
	case doctorpatientlink.EdgePatient:
		if id := m.patient; id != nil {
			return []ent.Value{*id}
		}
	case doctorpatientlink.EdgeApprovedBy:
		if id := m.approved_by; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DoctorPatientLinkMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DoctorPatientLinkMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DoctorPatientLinkMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareddoctor {
		edges = append(edges, doctorpatientlink.EdgeDoctor)
	}
	if m.clearedpatient {
		edges = append(edges, doctorpatientlink.EdgePatient)
	}
	if m.clearedapproved_by {
		edges = append(edges, doctorpatientlink.EdgeApprovedBy)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DoctorPatientLinkMutation) EdgeCleared(name string) bool {
	switch name {
	case doctorpatientlink.EdgeDoctor:
		return m.cleareddoctor
	case doctorpatientlink.EdgePatient:
		return m.clearedpatient
	case doctorpatientlink.EdgeApprovedBy:
		return m.clearedapproved_by
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DoctorPatientLinkMutation) ClearEdge(name string) error {
	switch name {
	case doctorpatientlink.EdgeDoctor:
		m.ClearDoctor()
		return nil
	case doctorpatientlink.EdgePatient:
		m.ClearPatient()
		return nil
	case doctorpatientlink.EdgeApprovedBy:
		m.ClearApprovedBy()
		return nil
	}
	return fmt.Errorf("unknown DoctorPatientLink unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DoctorPatientLinkMutation) ResetEdge(name string) error {
	switch name {
	case doctorpatientlink.EdgeDoctor:
		m.ResetDoctor()
		return nil
	case doctorpatientlink.EdgePatient:
		m.ResetPatient()
		return nil
	case doctorpatientlink.EdgeApprovedBy:
		m.ResetApprovedBy()
		return nil
	}
	return fmt.Errorf("unknown DoctorPatientLink edge %s", name)
}

// EntryMutation represents an operation that mutates the Entry nodes in the graph.
type EntryMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	created_at           *time.Time
	updated_at           *time.Time
	happened_at          *time.Time
	situation            *string
	emotions             *[]schema.Emotion
	appendemotions       []schema.Emotion
	triggers             *[]string
	appendtriggers       []string
	techniques           *[]string
	appendtechniques     []string
	stutter_frequency    *int
	addstutter_frequency *int
	notes                *string
	tags                 *[]string
	appendtags           []string
	clearedFields        map[string]struct{}
	patient              *uuid.UUID
	clearedpatient       bool
	shares               map[uuid.UUID]struct{}
	removedshares        map[uuid.UUID]struct{}
	clearedshares        bool
	comments             map[uuid.UUID]struct{}
	removedcomments      map[uuid.UUID]struct{}
	clearedcomments      bool
	analysis_jobs        map[uuid.UUID]struct{}
	removedanalysis_jobs map[uuid.UUID]struct{}
	clearedanalysis_jobs bool
	done                 bool
	oldValue             func(context.Context) (*Entry, error)
	predicates           []predicate.Entry
}

var _ ent.Mutation = (*EntryMutation)(nil)

// entryOption allows management of the mutation configuration using functional options.
type entryOption func(*EntryMutation)

// newEntryMutation creates new mutation for the Entry entity.
func newEntryMutation(c config, op Op, opts ...entryOption) *EntryMutation {
	m := &EntryMutation{
		config:        c,
		op:            op,
		typ:           TypeEntry,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEntryID sets the ID field of the mutation.
func withEntryID(id uuid.UUID) entryOption {
	return func(m *EntryMutation) {
		var (
			err   error
			once  sync.Once
			value *Entry
		)
		m.oldValue = func(ctx context.Context) (*Entry, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Entry.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEntry sets the old Entry of the mutation.
func withEntry(node *Entry) entryOption {
	return func(m *EntryMutation) {
		m.oldValue = func(context.Context) (*Entry, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EntryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EntryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Entry entities.
func (m *EntryMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EntryMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EntryMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Entry.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *EntryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EntryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Entry entity.
// If the Entry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EntryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EntryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EntryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Entry entity.
// If the Entry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EntryMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetPatientID sets the "patient_id" field.
func (m *EntryMutation) SetPatientID(u uuid.UUID) {
	m.patient = &u
}

// PatientID returns the value of the "patient_id" field in the mutation.
func (m *EntryMutation) PatientID() (r uuid.UUID, exists bool) {
	v := m.patient
	if v == nil {
		return
	}
	return *v, true
}

// OldPatientID returns the old "patient_id" field's value of the Entry entity.
// If the Entry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntryMutation) OldPatientID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPatientID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPatientID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPatientID: %w", err)
	}
	return oldValue.PatientID, nil
}

// ResetPatientID resets all changes to the "patient_id" field.
func (m *EntryMutation) ResetPatientID() {
	m.patient = nil
}

// SetHappenedAt sets the "happened_at" field.
func (m *EntryMutation) SetHappenedAt(t time.Time) {
	m.happened_at = &t
}

// HappenedAt returns the value of the "happened_at" field in the mutation.
func (m *EntryMutation) HappenedAt() (r time.Time, exists bool) {
	v := m.happened_at
	if v == nil {
		return
	}
	return *v, true
}

// OldHappenedAt returns the old "happened_at" field's value of the Entry entity.
// If the Entry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntryMutation) OldHappenedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHappenedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHappenedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHappenedAt: %w", err)
	}
	return oldValue.HappenedAt, nil
}

// ResetHappenedAt resets all changes to the "happened_at" field.
func (m *EntryMutation) ResetHappenedAt() {
	m.happened_at = nil
}

// SetSituation sets the "situation" field.
func (m *EntryMutation) SetSituation(s string) {
	m.situation = &s
}

// Situation returns the value of the "situation" field in the mutation.
func (m *EntryMutation) Situation() (r string, exists bool) {
	v := m.situation
	if v == nil {
		return
	}
	return *v, true
}

// OldSituation returns the old "situation" field's value of the Entry entity.
// If the Entry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntryMutation) OldSituation(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSituation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSituation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSituation: %w", err)
	}
	return oldValue.Situation, nil
}

// ClearSituation clears the value of the "situation" field.
func (m *EntryMutation) ClearSituation() {
	m.situation = nil
	m.clearedFields[entry.FieldSituation] = struct{}{}
}

// SituationCleared returns if the "situation" field was cleared in this mutation.
func (m *EntryMutation) SituationCleared() bool {
	_, ok := m.clearedFields[entry.FieldSituation]
	return ok
}

// ResetSituation resets all changes to the "situation" field.
func (m *EntryMutation) ResetSituation() {
	m.situation = nil
	delete(m.clearedFields, entry.FieldSituation)
}

// SetEmotions sets the "emotions" field.
func (m *EntryMutation) SetEmotions(s []schema.Emotion) {
	m.emotions = &s
	m.appendemotions = nil
}

// Emotions returns the value of the "emotions" field in the mutation.
func (m *EntryMutation) Emotions() (r []schema.Emotion, exists bool) {
	v := m.emotions
	if v == nil {
		return
	}
	return *v, true
}

// OldEmotions returns the old "emotions" field's value of the Entry entity.
// If the Entry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntryMutation) OldEmotions(ctx context.Context) (v []schema.Emotion, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmotions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmotions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmotions: %w", err)
	}
	return oldValue.Emotions, nil
}

// AppendEmotions adds s to the "emotions" field.
func (m *EntryMutation) AppendEmotions(s []schema.Emotion) {
	m.appendemotions = append(m.appendemotions, s...)
}

// AppendedEmotions returns the list of values that were appended to the "emotions" field in this mutation.
func (m *EntryMutation) AppendedEmotions() ([]schema.Emotion, bool) {
	if len(m.appendemotions) == 0 {
		return nil, false
	}
	return m.appendemotions, true
}

// ClearEmotions clears the value of the "emotions" field.
func (m *EntryMutation) ClearEmotions() {
	m.emotions = nil
	m.appendemotions = nil
	m.clearedFields[entry.FieldEmotions] = struct{}{}
}

// EmotionsCleared returns if the "emotions" field was cleared in this mutation.
func (m *EntryMutation) EmotionsCleared() bool {
	_, ok := m.clearedFields[entry.FieldEmotions]
	return ok
}

// ResetEmotions resets all changes to the "emotions" field.
func (m *EntryMutation) ResetEmotions() {
	m.emotions = nil
	m.appendemotions = nil
	delete(m.clearedFields, entry.FieldEmotions)
}

// SetTriggers sets the "triggers" field.
func (m *EntryMutation) SetTriggers(s []string) {
	m.triggers = &s
	m.appendtriggers = nil
}

// Triggers returns the value of the "triggers" field in the mutation.
func (m *EntryMutation) Triggers() (r []string, exists bool) {
	v := m.triggers
	if v == nil {
		return
	}
	return *v, true
}

// OldTriggers returns the old "triggers" field's value of the Entry entity.
// If the Entry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntryMutation) OldTriggers(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTriggers is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTriggers requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTriggers: %w", err)
	}
	return oldValue.Triggers, nil
}

// AppendTriggers adds s to the "triggers" field.
func (m *EntryMutation) AppendTriggers(s []string) {
	m.appendtriggers = append(m.appendtriggers, s...)
}

// AppendedTriggers returns the list of values that were appended to the "triggers" field in this mutation.
func (m *EntryMutation) AppendedTriggers() ([]string, bool) {
	if len(m.appendtriggers) == 0 {
		return nil, false
	}
	return m.appendtriggers, true
}

// ClearTriggers clears the value of the "triggers" field.
func (m *EntryMutation) ClearTriggers() {
	m.triggers = nil
	m.appendtriggers = nil
	m.clearedFields[entry.FieldTriggers] = struct{}{}
}

// TriggersCleared returns if the "triggers" field was cleared in this mutation.
func (m *EntryMutation) TriggersCleared() bool {
	_, ok := m.clearedFields[entry.FieldTriggers]
	return ok
}

// ResetTriggers resets all changes to the "triggers" field.
func (m *EntryMutation) ResetTriggers() {
	m.triggers = nil
	m.appendtriggers = nil
	delete(m.clearedFields, entry.FieldTriggers)
}

// SetTechniques sets the "techniques" field.
func (m *EntryMutation) SetTechniques(s []string) {
	m.techniques = &s
	m.appendtechniques = nil
}

// Techniques returns the value of the "techniques" field in the mutation.
func (m *EntryMutation) Techniques() (r []string, exists bool) {
	v := m.techniques
	if v == nil {
		return
	}
	return *v, true
}

// OldTechniques returns the old "techniques" field's value of the Entry entity.
// If the Entry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntryMutation) OldTechniques(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTechniques is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTechniques requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTechniques: %w", err)
	}
	return oldValue.Techniques, nil
}

// AppendTechniques adds s to the "techniques" field.
func (m *EntryMutation) AppendTechniques(s []string) {
	m.appendtechniques = append(m.appendtechniques, s...)
}

// AppendedTechniques returns the list of values that were appended to the "techniques" field in this mutation.
func (m *EntryMutation) AppendedTechniques() ([]string, bool) {
	if len(m.appendtechniques) == 0 {
		return nil, false
	}
	return m.appendtechniques, true
}

// ClearTechniques clears the value of the "techniques" field.
func (m *EntryMutation) ClearTechniques() {
	m.techniques = nil
	m.appendtechniques = nil
	m.clearedFields[entry.FieldTechniques] = struct{}{}
}

// TechniquesCleared returns if the "techniques" field was cleared in this mutation.
func (m *EntryMutation) TechniquesCleared() bool {
	_, ok := m.clearedFields[entry.FieldTechniques]
	return ok
}

// ResetTechniques resets all changes to the "techniques" field.
func (m *EntryMutation) ResetTechniques() {
	m.techniques = nil
	m.appendtechniques = nil
	delete(m.clearedFields, entry.FieldTechniques)
}

// SetStutterFrequency sets the "stutter_frequency" field.
func (m *EntryMutation) SetStutterFrequency(i int) {
	m.stutter_frequency = &i
	m.addstutter_frequency = nil
}

// StutterFrequency returns the value of the "stutter_frequency" field in the mutation.
func (m *EntryMutation) StutterFrequency() (r int, exists bool) {
	v := m.stutter_frequency
	if v == nil {
		return
	}
	return *v, true
}

// OldStutterFrequency returns the old "stutter_frequency" field's value of the Entry entity.
// If the Entry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntryMutation) OldStutterFrequency(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStutterFrequency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStutterFrequency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStutterFrequency: %w", err)
	}
	return oldValue.StutterFrequency, nil
}

// AddStutterFrequency adds i to the "stutter_frequency" field.
func (m *EntryMutation) AddStutterFrequency(i int) {
	if m.addstutter_frequency != nil {
		*m.addstutter_frequency += i
	} else {
		m.addstutter_frequency = &i
	}
}

// AddedStutterFrequency returns the value that was added to the "stutter_frequency" field in this mutation.
func (m *EntryMutation) AddedStutterFrequency() (r int, exists bool) {
	v := m.addstutter_frequency
	if v == nil {
		return
	}
	return *v, true
}

// ClearStutterFrequency clears the value of the "stutter_frequency" field.
func (m *EntryMutation) ClearStutterFrequency() {
	m.stutter_frequency = nil
	m.addstutter_frequency = nil
	m.clearedFields[entry.FieldStutterFrequency] = struct{}{}
}

// StutterFrequencyCleared returns if the "stutter_frequency" field was cleared in this mutation.
func (m *EntryMutation) StutterFrequencyCleared() bool {
	_, ok := m.clearedFields[entry.FieldStutterFrequency]
	return ok
}

// ResetStutterFrequency resets all changes to the "stutter_frequency" field.
func (m *EntryMutation) ResetStutterFrequency() {
	m.stutter_frequency = nil
	m.addstutter_frequency = nil
	delete(m.clearedFields, entry.FieldStutterFrequency)
}

// SetNotes sets the "notes" field.
func (m *EntryMutation) SetNotes(s string) {
	m.notes = &s
}

// Notes returns the value of the "notes" field in the mutation.
func (m *EntryMutation) Notes() (r string, exists bool) {
	v := m.notes
	if v == nil {
		return
	}
	return *v, true
}

// OldNotes returns the old "notes" field's value of the Entry entity.
// If the Entry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntryMutation) OldNotes(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotes: %w", err)
	}
	return oldValue.Notes, nil
}

// ClearNotes clears the value of the "notes" field.
func (m *EntryMutation) ClearNotes() {
	m.notes = nil
	m.clearedFields[entry.FieldNotes] = struct{}{}
}

// NotesCleared returns if the "notes" field was cleared in this mutation.
func (m *EntryMutation) NotesCleared() bool {
	_, ok := m.clearedFields[entry.FieldNotes]
	return ok
}

// ResetNotes resets all changes to the "notes" field.
func (m *EntryMutation) ResetNotes() {
	m.notes = nil
	delete(m.clearedFields, entry.FieldNotes)
}

// SetTags sets the "tags" field.
func (m *EntryMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *EntryMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Entry entity.
// If the Entry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntryMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *EntryMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *EntryMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *EntryMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[entry.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *EntryMutation) TagsCleared() bool {
	_, ok := m.clearedFields[entry.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *EntryMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, entry.FieldTags)
}

// ClearPatient clears the "patient" edge to the Patient entity.
func (m *EntryMutation) ClearPatient() {
	m.clearedpatient = true
	m.clearedFields[entry.FieldPatientID] = struct{}{}
}

// PatientCleared reports if the "patient" edge to the Patient entity was cleared.
func (m *EntryMutation) PatientCleared() bool {
	return m.clearedpatient
}

// PatientIDs returns the "patient" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PatientID instead. It exists only for internal usage by the builders.
func (m *EntryMutation) PatientIDs() (ids []uuid.UUID) {
	if id := m.patient; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPatient resets all changes to the "patient" edge.
func (m *EntryMutation) ResetPatient() {
	m.patient = nil
	m.clearedpatient = false
}

// AddShareIDs adds the "shares" edge to the EntryShare entity by ids.
func (m *EntryMutation) AddShareIDs(ids ...uuid.UUID) {
	if m.shares == nil {
		m.shares = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.shares[ids[i]] = struct{}{}
	}
}

// ClearShares clears the "shares" edge to the EntryShare entity.
func (m *EntryMutation) ClearShares() {
	m.clearedshares = true
}

// SharesCleared reports if the "shares" edge to the EntryShare entity was cleared.
func (m *EntryMutation) SharesCleared() bool {
	return m.clearedshares
}

// RemoveShareIDs removes the "shares" edge to the EntryShare entity by IDs.
func (m *EntryMutation) RemoveShareIDs(ids ...uuid.UUID) {
	if m.removedshares == nil {
		m.removedshares = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.shares, ids[i])
		m.removedshares[ids[i]] = struct{}{}
	}
}

// RemovedShares returns the removed IDs of the "shares" edge to the EntryShare entity.
func (m *EntryMutation) RemovedSharesIDs() (ids []uuid.UUID) {
	for id := range m.removedshares {
		ids = append(ids, id)
	}
	return
}

// SharesIDs returns the "shares" edge IDs in the mutation.
func (m *EntryMutation) SharesIDs() (ids []uuid.UUID) {
	for id := range m.shares {
		ids = append(ids, id)
	}
	return
}

// ResetShares resets all changes to the "shares" edge.
func (m *EntryMutation) ResetShares() {
	m.shares = nil
	m.clearedshares = false
	m.removedshares = nil
}

// AddCommentIDs adds the "comments" edge to the Comment entity by ids.
func (m *EntryMutation) AddCommentIDs(ids ...uuid.UUID) {
	if m.comments == nil {
		m.comments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.comments[ids[i]] = struct{}{}
	}
}

// ClearComments clears the "comments" edge to the Comment entity.
func (m *EntryMutation) ClearComments() {
	m.clearedcomments = true
}

// CommentsCleared reports if the "comments" edge to the Comment entity was cleared.
func (m *EntryMutation) CommentsCleared() bool {
	return m.clearedcomments
}

// RemoveCommentIDs removes the "comments" edge to the Comment entity by IDs.
func (m *EntryMutation) RemoveCommentIDs(ids ...uuid.UUID) {
	if m.removedcomments == nil {
		m.removedcomments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.comments, ids[i])
		m.removedcomments[ids[i]] = struct{}{}
	}
}

// RemovedComments returns the removed IDs of the "comments" edge to the Comment entity.
func (m *EntryMutation) RemovedCommentsIDs() (ids []uuid.UUID) {
	for id := range m.removedcomments {
		ids = append(ids, id)
	}
	return
}

// CommentsIDs returns the "comments" edge IDs in the mutation.
func (m *EntryMutation) CommentsIDs() (ids []uuid.UUID) {
	for id := range m.comments {
		ids = append(ids, id)
	}
	return
}

// ResetComments resets all changes to the "comments" edge.
func (m *EntryMutation) ResetComments() {
	m.comments = nil
	m.clearedcomments = false
	m.removedcomments = nil
}

// AddAnalysisJobIDs adds the "analysis_jobs" edge to the AnalysisJob entity by ids.
func (m *EntryMutation) AddAnalysisJobIDs(ids ...uuid.UUID) {
	if m.analysis_jobs == nil {
		m.analysis_jobs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.analysis_jobs[ids[i]] = struct{}{}
	}
}

// ClearAnalysisJobs clears the "analysis_jobs" edge to the AnalysisJob entity.
func (m *EntryMutation) ClearAnalysisJobs() {
	m.clearedanalysis_jobs = true
}

// AnalysisJobsCleared reports if the "analysis_jobs" edge to the AnalysisJob entity was cleared.
func (m *EntryMutation) AnalysisJobsCleared() bool {
	return m.clearedanalysis_jobs
}

// RemoveAnalysisJobIDs removes the "analysis_jobs" edge to the AnalysisJob entity by IDs.
func (m *EntryMutation) RemoveAnalysisJobIDs(ids ...uuid.UUID) {
	if m.removedanalysis_jobs == nil {
		m.removedanalysis_jobs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.analysis_jobs, ids[i])
		m.removedanalysis_jobs[ids[i]] = struct{}{}
	}
}

// RemovedAnalysisJobs returns the removed IDs of the "analysis_jobs" edge to the AnalysisJob entity.
func (m *EntryMutation) RemovedAnalysisJobsIDs() (ids []uuid.UUID) {
	for id := range m.removedanalysis_jobs {
		ids = append(ids, id)
	}
	return
}

// AnalysisJobsIDs returns the "analysis_jobs" edge IDs in the mutation.
func (m *EntryMutation) AnalysisJobsIDs() (ids []uuid.UUID) {
	for id := range m.analysis_jobs {
		ids = append(ids, id)
	}
	return
}

// ResetAnalysisJobs resets all changes to the "analysis_jobs" edge.
func (m *EntryMutation) ResetAnalysisJobs() {
	m.analysis_jobs = nil
	m.clearedanalysis_jobs = false
	m.removedanalysis_jobs = nil
}

// Where appends a list predicates to the EntryMutation builder.
func (m *EntryMutation) Where(ps ...predicate.Entry) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EntryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EntryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Entry, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EntryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EntryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Entry).
func (m *EntryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EntryMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, entry.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, entry.FieldUpdatedAt)
	}
	if m.patient != nil {
		fields = append(fields, entry.FieldPatientID)
	}
	if m.happened_at != nil {
		fields = append(fields, entry.FieldHappenedAt)
	}
	if m.situation != nil {
		fields = append(fields, entry.FieldSituation)
	}
	if m.emotions != nil {
		fields = append(fields, entry.FieldEmotions)
	}
	if m.triggers != nil {
		fields = append(fields, entry.FieldTriggers)
	}
	if m.techniques != nil {
		fields = append(fields, entry.FieldTechniques)
	}
	if m.stutter_frequency != nil {
		fields = append(fields, entry.FieldStutterFrequency)
	}
	if m.notes != nil {
		fields = append(fields, entry.FieldNotes)
	}
	if m.tags != nil {
		fields = append(fields, entry.FieldTags)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EntryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case entry.FieldCreatedAt:
		return m.CreatedAt()
	case entry.FieldUpdatedAt:
		return m.UpdatedAt()
	case entry.FieldPatientID:
		return m.PatientID()
	case entry.FieldHappenedAt:
		return m.HappenedAt()
	case entry.FieldSituation:
		return m.Situation()
	case entry.FieldEmotions:
		return m.Emotions()
	case entry.FieldTriggers:
		return m.Triggers()
	case entry.FieldTechniques:
		return m.Techniques()
	case entry.FieldStutterFrequency:
		return m.StutterFrequency()
	case entry.FieldNotes:
		return m.Notes()
	case entry.FieldTags:
		return m.Tags()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EntryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case entry.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case entry.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case entry.FieldPatientID:
		return m.OldPatientID(ctx)
	case entry.FieldHappenedAt:
		return m.OldHappenedAt(ctx)
	case entry.FieldSituation:
		return m.OldSituation(ctx)
	case entry.FieldEmotions:
		return m.OldEmotions(ctx)
	case entry.FieldTriggers:
		return m.OldTriggers(ctx)
	case entry.FieldTechniques:
		return m.OldTechniques(ctx)
	case entry.FieldStutterFrequency:
		return m.OldStutterFrequency(ctx)
	case entry.FieldNotes:
		return m.OldNotes(ctx)
	case entry.FieldTags:
		return m.OldTags(ctx)
	}
	return nil, fmt.Errorf("unknown Entry field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EntryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case entry.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case entry.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case entry.FieldPatientID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPatientID(v)
		return nil
	case entry.FieldHappenedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHappenedAt(v)
		return nil
	case entry.FieldSituation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSituation(v)
		return nil
	case entry.FieldEmotions:
		v, ok := value.([]schema.Emotion)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmotions(v)
		return nil
	case entry.FieldTriggers:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTriggers(v)
		return nil
	case entry.FieldTechniques:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTechniques(v)
		return nil
	case entry.FieldStutterFrequency:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStutterFrequency(v)
		return nil
	case entry.FieldNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotes(v)
		return nil
	case entry.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	}
	return fmt.Errorf("unknown Entry field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EntryMutation) AddedFields() []string {
	var fields []string
	if m.addstutter_frequency != nil {
		fields = append(fields, entry.FieldStutterFrequency)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EntryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case entry.FieldStutterFrequency:
		return m.AddedStutterFrequency()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EntryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case entry.FieldStutterFrequency:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStutterFrequency(v)
		return nil
	}
	return fmt.Errorf("unknown Entry numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EntryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(entry.FieldSituation) {
		fields = append(fields, entry.FieldSituation)
	}
	if m.FieldCleared(entry.FieldEmotions) {
		fields = append(fields, entry.FieldEmotions)
	}
	if m.FieldCleared(entry.FieldTriggers) {
		fields = append(fields, entry.FieldTriggers)
	}
	if m.FieldCleared(entry.FieldTechniques) {
		fields = append(fields, entry.FieldTechniques)
	}
	if m.FieldCleared(entry.FieldStutterFrequency) {
		fields = append(fields, entry.FieldStutterFrequency)
	}
	if m.FieldCleared(entry.FieldNotes) {
		fields = append(fields, entry.FieldNotes)
	}
	if m.FieldCleared(entry.FieldTags) {
		fields = append(fields, entry.FieldTags)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EntryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EntryMutation) ClearField(name string) error {
	switch name {
	case entry.FieldSituation:
		m.ClearSituation()
		return nil
	case entry.FieldEmotions:
		m.ClearEmotions()
		return nil
	case entry.FieldTriggers:
		m.ClearTriggers()
		return nil
	case entry.FieldTechniques:
		m.ClearTechniques()
		return nil
	case entry.FieldStutterFrequency:
		m.ClearStutterFrequency()
		return nil
	case entry.FieldNotes:
		m.ClearNotes()
		return nil
	case entry.FieldTags:
		m.ClearTags()
		return nil
	}
	return fmt.Errorf("unknown Entry nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EntryMutation) ResetField(name string) error {
	switch name {
	case entry.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case entry.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case entry.FieldPatientID:
		m.ResetPatientID()
		return nil
	case entry.FieldHappenedAt:
		m.ResetHappenedAt()
		return nil
	case entry.FieldSituation:
		m.ResetSituation()
		return nil
	case entry.FieldEmotions:
		m.ResetEmotions()
		return nil
	case entry.FieldTriggers:
		m.ResetTriggers()
		return nil
	case entry.FieldTechniques:
		m.ResetTechniques()
		return nil
	case entry.FieldStutterFrequency:
		m.ResetStutterFrequency()
		return nil
	case entry.FieldNotes:
		m.ResetNotes()
		return nil
	case entry.FieldTags:
		m.ResetTags()
		return nil
	}
	return fmt.Errorf("unknown Entry field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EntryMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.patient != nil {
		edges = append(edges, entry.EdgePatient)
	}
	if m.shares != nil {
		edges = append(edges, entry.EdgeShares)
	}
	if m.comments != nil {
		edges = append(edges, entry.EdgeComments)
	}
	if m.analysis_jobs != nil {
		edges = append(edges, entry.EdgeAnalysisJobs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EntryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case entry.EdgePatient:
		if id := m.patient; id != nil {
			return []ent.Value{*id}
		}
	case entry.EdgeShares:
		ids := make([]ent.Value, 0, len(m.shares))
		for id := range m.shares {
			ids = append(ids, id)
		}
		return ids
	case entry.EdgeComments:
		ids := make([]ent.Value, 0, len(m.comments))
		for id := range m.comments {
			ids = append(ids, id)
		}
		return ids
	case entry.EdgeAnalysisJobs:
		ids := make([]ent.Value, 0, len(m.analysis_jobs))
		for id := range m.analysis_jobs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EntryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedshares != nil {
		edges = append(edges, entry.EdgeShares)
	}
	if m.removedcomments != nil {
		edges = append(edges, entry.EdgeComments)
	}
	if m.removedanalysis_jobs != nil {
		edges = append(edges, entry.EdgeAnalysisJobs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EntryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case entry.EdgeShares:
		ids := make([]ent.Value, 0, len(m.removedshares))
		for id := range m.removedshares {
			ids = append(ids, id)
		}
		return ids
	case entry.EdgeComments:
		ids := make([]ent.Value, 0, len(m.removedcomments))
		for id := range m.removedcomments {
			ids = append(ids, id)
		}
		return ids
	case entry.EdgeAnalysisJobs:
		ids := make([]ent.Value, 0, len(m.removedanalysis_jobs))
		for id := range m.removedanalysis_jobs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EntryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedpatient {
		edges = append(edges, entry.EdgePatient)
	}
	if m.clearedshares {
		edges = append(edges, entry.EdgeShares)
	}
	if m.clearedcomments {
		edges = append(edges, entry.EdgeComments)
	}
	if m.clearedanalysis_jobs {
		edges = append(edges, entry.EdgeAnalysisJobs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EntryMutation) EdgeCleared(name string) bool {
	switch name {
	case entry.EdgePatient:
		return m.clearedpatient
	case entry.EdgeShares:
		return m.clearedshares
	case entry.EdgeComments:
		return m.clearedcomments
	case entry.EdgeAnalysisJobs:
		return m.clearedanalysis_jobs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EntryMutation) ClearEdge(name string) error {
	switch name {
	case entry.EdgePatient:
		m.ClearPatient()
		return nil
	}
	return fmt.Errorf("unknown Entry unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EntryMutation) ResetEdge(name string) error {
	switch name {
	case entry.EdgePatient:
		m.ResetPatient()
		return nil
	case entry.EdgeShares:
		m.ResetShares()
		return nil
	case entry.EdgeComments:
		m.ResetComments()
		return nil
	case entry.EdgeAnalysisJobs:
		m.ResetAnalysisJobs()
		return nil
	}
	return fmt.Errorf("unknown Entry edge %s", name)
}

// EntryShareMutation represents an operation that mutates the EntryShare nodes in the graph.
type EntryShareMutation struct {
	config
	op                        Op
	typ                       string
	id                        *uuid.UUID
	created_at                *time.Time
	updated_at                *time.Time
	shared_at                 *time.Time
	revoked_at                *time.Time
	clearedFields             map[string]struct{}
	entry                     *uuid.UUID
	clearedentry              bool
	shared_by_patient         *uuid.UUID
	clearedshared_by_patient  bool
	shared_with_doctor        *uuid.UUID
	clearedshared_with_doctor bool
	done                      bool
	oldValue                  func(context.Context) (*EntryShare, error)
	predicates                []predicate.EntryShare
}

var _ ent.Mutation = (*EntryShareMutation)(nil)

// entryshareOption allows management of the mutation configuration using functional options.
type entryshareOption func(*EntryShareMutation)

// newEntryShareMutation creates new mutation for the EntryShare entity.
func newEntryShareMutation(c config, op Op, opts ...entryshareOption) *EntryShareMutation {
	m := &EntryShareMutation{
		config:        c,
		op:            op,
		typ:           TypeEntryShare,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEntryShareID sets the ID field of the mutation.
func withEntryShareID(id uuid.UUID) entryshareOption {
	return func(m *EntryShareMutation) {
		var (
			err   error
			once  sync.Once
			value *EntryShare
		)
		m.oldValue = func(ctx context.Context) (*EntryShare, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EntryShare.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEntryShare sets the old EntryShare of the mutation.
func withEntryShare(node *EntryShare) entryshareOption {
	return func(m *EntryShareMutation) {
		m.oldValue = func(context.Context) (*EntryShare, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EntryShareMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EntryShareMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EntryShare entities.
func (m *EntryShareMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EntryShareMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EntryShareMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EntryShare.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *EntryShareMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EntryShareMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EntryShare entity.
// If the EntryShare object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntryShareMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EntryShareMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EntryShareMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EntryShareMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the EntryShare entity.
// If the EntryShare object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntryShareMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EntryShareMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetEntryID sets the "entry_id" field.
func (m *EntryShareMutation) SetEntryID(u uuid.UUID) {
	m.entry = &u
}

// EntryID returns the value of the "entry_id" field in the mutation.
func (m *EntryShareMutation) EntryID() (r uuid.UUID, exists bool) {
	v := m.entry
	if v == nil {
		return
	}
	return *v, true
}

// OldEntryID returns the old "entry_id" field's value of the EntryShare entity.
// If the EntryShare object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntryShareMutation) OldEntryID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntryID: %w", err)
	}
	return oldValue.EntryID, nil
}

// ResetEntryID resets all changes to the "entry_id" field.
func (m *EntryShareMutation) ResetEntryID() {
	m.entry = nil
}

// SetSharedByPatientID sets the "shared_by_patient_id" field.
func (m *EntryShareMutation) SetSharedByPatientID(u uuid.UUID) {
	m.shared_by_patient = &u
}

// SharedByPatientID returns the value of the "shared_by_patient_id" field in the mutation.
func (m *EntryShareMutation) SharedByPatientID() (r uuid.UUID, exists bool) {
	v := m.shared_by_patient
	if v == nil {
		return
	}
	return *v, true
}

// OldSharedByPatientID returns the old "shared_by_patient_id" field's value of the EntryShare entity.
// If the EntryShare object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntryShareMutation) OldSharedByPatientID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSharedByPatientID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSharedByPatientID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSharedByPatientID: %w", err)
	}
	return oldValue.SharedByPatientID, nil
}

// ResetSharedByPatientID resets all changes to the "shared_by_patient_id" field.
func (m *EntryShareMutation) ResetSharedByPatientID() {
	m.shared_by_patient = nil
}

// SetSharedWithDoctorID sets the "shared_with_doctor_id" field.
func (m *EntryShareMutation) SetSharedWithDoctorID(u uuid.UUID) {
	m.shared_with_doctor = &u
}

// SharedWithDoctorID returns the value of the "shared_with_doctor_id" field in the mutation.
func (m *EntryShareMutation) SharedWithDoctorID() (r uuid.UUID, exists bool) {
	v := m.shared_with_doctor
	if v == nil {
		return
	}
	return *v, true
}

// OldSharedWithDoctorID returns the old "shared_with_doctor_id" field's value of the EntryShare entity.
// If the EntryShare object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntryShareMutation) OldSharedWithDoctorID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSharedWithDoctorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSharedWithDoctorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSharedWithDoctorID: %w", err)
	}
	return oldValue.SharedWithDoctorID, nil
}

// ResetSharedWithDoctorID resets all changes to the "shared_with_doctor_id" field.
func (m *EntryShareMutation) ResetSharedWithDoctorID() {
	m.shared_with_doctor = nil
}

// SetSharedAt sets the "shared_at" field.
func (m *EntryShareMutation) SetSharedAt(t time.Time) {
	m.shared_at = &t
}

// SharedAt returns the value of the "shared_at" field in the mutation.
func (m *EntryShareMutation) SharedAt() (r time.Time, exists bool) {
	v := m.shared_at
	if v == nil {
		return
	}
	return *v, true
}

// OldSharedAt returns the old "shared_at" field's value of the EntryShare entity.
// If the EntryShare object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntryShareMutation) OldSharedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSharedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSharedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSharedAt: %w", err)
	}
	return oldValue.SharedAt, nil
}

// ResetSharedAt resets all changes to the "shared_at" field.
func (m *EntryShareMutation) ResetSharedAt() {
	m.shared_at = nil
}

// SetRevokedAt sets the "revoked_at" field.
func (m *EntryShareMutation) SetRevokedAt(t time.Time) {
	m.revoked_at = &t
}

// RevokedAt returns the value of the "revoked_at" field in the mutation.
func (m *EntryShareMutation) RevokedAt() (r time.Time, exists bool) {
	v := m.revoked_at
	if v == nil {
		return
	}
	return *v, true
}

// OldRevokedAt returns the old "revoked_at" field's value of the EntryShare entity.
// If the EntryShare object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntryShareMutation) OldRevokedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevokedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevokedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevokedAt: %w", err)
	}
	return oldValue.RevokedAt, nil
}

// ClearRevokedAt clears the value of the "revoked_at" field.
func (m *EntryShareMutation) ClearRevokedAt() {
	m.revoked_at = nil
	m.clearedFields[entryshare.FieldRevokedAt] = struct{}{}
}

// RevokedAtCleared returns if the "revoked_at" field was cleared in this mutation.
func (m *EntryShareMutation) RevokedAtCleared() bool {
	_, ok := m.clearedFields[entryshare.FieldRevokedAt]
	return ok
}

// ResetRevokedAt resets all changes to the "revoked_at" field.
func (m *EntryShareMutation) ResetRevokedAt() {
	m.revoked_at = nil
	delete(m.clearedFields, entryshare.FieldRevokedAt)
}

// ClearEntry clears the "entry" edge to the Entry entity.
func (m *EntryShareMutation) ClearEntry() {
	m.clearedentry = true
	m.clearedFields[entryshare.FieldEntryID] = struct{}{}
}

// EntryCleared reports if the "entry" edge to the Entry entity was cleared.
func (m *EntryShareMutation) EntryCleared() bool {
	return m.clearedentry
}

// EntryIDs returns the "entry" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EntryID instead. It exists only for internal usage by the builders.
func (m *EntryShareMutation) EntryIDs() (ids []uuid.UUID) {
	if id := m.entry; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEntry resets all changes to the "entry" edge.
func (m *EntryShareMutation) ResetEntry() {
	m.entry = nil
	m.clearedentry = false
}

// ClearSharedByPatient clears the "shared_by_patient" edge to the Patient entity.
func (m *EntryShareMutation) ClearSharedByPatient() {
	m.clearedshared_by_patient = true
	m.clearedFields[entryshare.FieldSharedByPatientID] = struct{}{}
}

// SharedByPatientCleared reports if the "shared_by_patient" edge to the Patient entity was cleared.
func (m *EntryShareMutation) SharedByPatientCleared() bool {
	return m.clearedshared_by_patient
}

// SharedByPatientIDs returns the "shared_by_patient" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SharedByPatientID instead. It exists only for internal usage by the builders.
func (m *EntryShareMutation) SharedByPatientIDs() (ids []uuid.UUID) {
	if id := m.shared_by_patient; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSharedByPatient resets all changes to the "shared_by_patient" edge.
func (m *EntryShareMutation) ResetSharedByPatient() {
	m.shared_by_patient = nil
	m.clearedshared_by_patient = false
}

// ClearSharedWithDoctor clears the "shared_with_doctor" edge to the Doctor entity.
func (m *EntryShareMutation) ClearSharedWithDoctor() {
	m.clearedshared_with_doctor = true
	m.clearedFields[entryshare.FieldSharedWithDoctorID] = struct{}{}
}

// SharedWithDoctorCleared reports if the "shared_with_doctor" edge to the Doctor entity was cleared.
func (m *EntryShareMutation) SharedWithDoctorCleared() bool {
	return m.clearedshared_with_doctor
}

// SharedWithDoctorIDs returns the "shared_with_doctor" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SharedWithDoctorID instead. It exists only for internal usage by the builders.
func (m *EntryShareMutation) SharedWithDoctorIDs() (ids []uuid.UUID) {
	if id := m.shared_with_doctor; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSharedWithDoctor resets all changes to the "shared_with_doctor" edge.
func (m *EntryShareMutation) ResetSharedWithDoctor() {
	m.shared_with_doctor = nil
	m.clearedshared_with_doctor = false
}

// Where appends a list predicates to the EntryShareMutation builder.
func (m *EntryShareMutation) Where(ps ...predicate.EntryShare) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EntryShareMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EntryShareMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EntryShare, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EntryShareMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EntryShareMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EntryShare).
func (m *EntryShareMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EntryShareMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, entryshare.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, entryshare.FieldUpdatedAt)
	}
	if m.entry != nil {
		fields = append(fields, entryshare.FieldEntryID)
	}
	if m.shared_by_patient != nil {
		fields = append(fields, entryshare.FieldSharedByPatientID)
	}
	if m.shared_with_doctor != nil {
		fields = append(fields, entryshare.FieldSharedWithDoctorID)
	}
	if m.shared_at != nil {
		fields = append(fields, entryshare.FieldSharedAt)
	}
	if m.revoked_at != nil {
		fields = append(fields, entryshare.FieldRevokedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EntryShareMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case entryshare.FieldCreatedAt:
		return m.CreatedAt()
	case entryshare.FieldUpdatedAt:
		return m.UpdatedAt()
	case entryshare.FieldEntryID:
		return m.EntryID()
	case entryshare.FieldSharedByPatientID:
		return m.SharedByPatientID()
	case entryshare.FieldSharedWithDoctorID:
		return m.SharedWithDoctorID()
	case entryshare.FieldSharedAt:
		return m.SharedAt()
	case entryshare.FieldRevokedAt:
		return m.RevokedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EntryShareMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case entryshare.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case entryshare.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case entryshare.FieldEntryID:
		return m.OldEntryID(ctx)
	case entryshare.FieldSharedByPatientID:
		return m.OldSharedByPatientID(ctx)
	case entryshare.FieldSharedWithDoctorID:
		return m.OldSharedWithDoctorID(ctx)
	case entryshare.FieldSharedAt:
		return m.OldSharedAt(ctx)
	case entryshare.FieldRevokedAt:
		return m.OldRevokedAt(ctx)
	}
	return nil, fmt.Errorf("unknown EntryShare field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EntryShareMutation) SetField(name string, value ent.Value) error {
	switch name {
	case entryshare.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case entryshare.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case entryshare.FieldEntryID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntryID(v)
		return nil
	case entryshare.FieldSharedByPatientID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSharedByPatientID(v)
		return nil
	case entryshare.FieldSharedWithDoctorID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSharedWithDoctorID(v)
		return nil
	case entryshare.FieldSharedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSharedAt(v)
		return nil
	case entryshare.FieldRevokedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevokedAt(v)
		return nil
	}
	return fmt.Errorf("unknown EntryShare field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EntryShareMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EntryShareMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EntryShareMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EntryShare numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EntryShareMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(entryshare.FieldRevokedAt) {
		fields = append(fields, entryshare.FieldRevokedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EntryShareMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EntryShareMutation) ClearField(name string) error {
	switch name {
	case entryshare.FieldRevokedAt:
		m.ClearRevokedAt()
		return nil
	}
	return fmt.Errorf("unknown EntryShare nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EntryShareMutation) ResetField(name string) error {
	switch name {
	case entryshare.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case entryshare.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case entryshare.FieldEntryID:
		m.ResetEntryID()
		return nil
	case entryshare.FieldSharedByPatientID:
		m.ResetSharedByPatientID()
		return nil
	case entryshare.FieldSharedWithDoctorID:
		m.ResetSharedWithDoctorID()
		return nil
	case entryshare.FieldSharedAt:
		m.ResetSharedAt()
		return nil
	case entryshare.FieldRevokedAt:
		m.ResetRevokedAt()
		return nil
	}
	return fmt.Errorf("unknown EntryShare field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EntryShareMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.entry != nil {
		edges = append(edges, entryshare.EdgeEntry)
	}
	if m.shared_by_patient != nil {
		edges = append(edges, entryshare.EdgeSharedByPatient)
	}
	if m.shared_with_doctor != nil {
		edges = append(edges, entryshare.EdgeSharedWithDoctor)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EntryShareMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case entryshare.EdgeEntry:
		if id := m.entry; id != nil {
			return []ent.Value{*id}
		}
	case entryshare.EdgeSharedByPatient:
		if id := m.shared_by_patient; id != nil {
			return []ent.Value{*id}
		}
	case entryshare.EdgeSharedWithDoctor:
		if id := m.shared_with_doctor; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EntryShareMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EntryShareMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EntryShareMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedentry {
		edges = append(edges, entryshare.EdgeEntry)
	}
	if m.clearedshared_by_patient {
		edges = append(edges, entryshare.EdgeSharedByPatient)
	}
	if m.clearedshared_with_doctor {
		edges = append(edges, entryshare.EdgeSharedWithDoctor)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EntryShareMutation) EdgeCleared(name string) bool {
	switch name {
	case entryshare.EdgeEntry:
		return m.clearedentry
	case entryshare.EdgeSharedByPatient:
		return m.clearedshared_by_patient
	case entryshare.EdgeSharedWithDoctor:
		return m.clearedshared_with_doctor
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EntryShareMutation) ClearEdge(name string) error {
	switch name {
	case entryshare.EdgeEntry:
		m.ClearEntry()
		return nil
	case entryshare.EdgeSharedByPatient:
		m.ClearSharedByPatient()
		return nil
	case entryshare.EdgeSharedWithDoctor:
		m.ClearSharedWithDoctor()
		return nil
	}
	return fmt.Errorf("unknown EntryShare unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EntryShareMutation) ResetEdge(name string) error {
	switch name {
	case entryshare.EdgeEntry:
		m.ResetEntry()
		return nil
	case entryshare.EdgeSharedByPatient:
		m.ResetSharedByPatient()
		return nil
	case entryshare.EdgeSharedWithDoctor:
		m.ResetSharedWithDoctor()
		return nil
	}
	return fmt.Errorf("unknown EntryShare edge %s", name)
}

// PairingCodeMutation represents an operation that mutates the PairingCode nodes in the graph.
type PairingCodeMutation struct {
	config
	op                         Op
	typ                        string
	id                         *uuid.UUID
	created_at                 *time.Time
	updated_at                 *time.Time
	code                       *string
	expires_at                 *time.Time
	consumed_at                *time.Time
	clearedFields              map[string]struct{}
	doctor                     *uuid.UUID
	cleareddoctor              bool
	consumed_by_patient        *uuid.UUID
	clearedconsumed_by_patient bool
	done                       bool
	oldValue                   func(context.Context) (*PairingCode, error)
	predicates                 []predicate.PairingCode
}

var _ ent.Mutation = (*PairingCodeMutation)(nil)

// pairingcodeOption allows management of the mutation configuration using functional options.
type pairingcodeOption func(*PairingCodeMutation)

// newPairingCodeMutation creates new mutation for the PairingCode entity.
func newPairingCodeMutation(c config, op Op, opts ...pairingcodeOption) *PairingCodeMutation {
	m := &PairingCodeMutation{
		config:        c,
		op:            op,
		typ:           TypePairingCode,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPairingCodeID sets the ID field of the mutation.
func withPairingCodeID(id uuid.UUID) pairingcodeOption {
	return func(m *PairingCodeMutation) {
		var (
			err   error
			once  sync.Once
			value *PairingCode
		)
		m.oldValue = func(ctx context.Context) (*PairingCode, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PairingCode.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPairingCode sets the old PairingCode of the mutation.
func withPairingCode(node *PairingCode) pairingcodeOption {
	return func(m *PairingCodeMutation) {
		m.oldValue = func(context.Context) (*PairingCode, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PairingCodeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PairingCodeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PairingCode entities.
func (m *PairingCodeMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PairingCodeMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PairingCodeMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PairingCode.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PairingCodeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PairingCodeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PairingCode entity.
// If the PairingCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PairingCodeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PairingCodeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PairingCodeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PairingCodeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PairingCode entity.
// If the PairingCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PairingCodeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PairingCodeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCode sets the "code" field.
func (m *PairingCodeMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *PairingCodeMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the PairingCode entity.
// If the PairingCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PairingCodeMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *PairingCodeMutation) ResetCode() {
	m.code = nil
}

// SetDoctorID sets the "doctor_id" field.
func (m *PairingCodeMutation) SetDoctorID(u uuid.UUID) {
	m.doctor = &u
}

// DoctorID returns the value of the "doctor_id" field in the mutation.
func (m *PairingCodeMutation) DoctorID() (r uuid.UUID, exists bool) {
	v := m.doctor
	if v == nil {
		return
	}
	return *v, true
}

// OldDoctorID returns the old "doctor_id" field's value of the PairingCode entity.
// If the PairingCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PairingCodeMutation) OldDoctorID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDoctorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDoctorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDoctorID: %w", err)
	}
	return oldValue.DoctorID, nil
}

// ResetDoctorID resets all changes to the "doctor_id" field.
func (m *PairingCodeMutation) ResetDoctorID() {
	m.doctor = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *PairingCodeMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *PairingCodeMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the PairingCode entity.
// If the PairingCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PairingCodeMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *PairingCodeMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// SetConsumedAt sets the "consumed_at" field.
func (m *PairingCodeMutation) SetConsumedAt(t time.Time) {
	m.consumed_at = &t
}

// ConsumedAt returns the value of the "consumed_at" field in the mutation.
func (m *PairingCodeMutation) ConsumedAt() (r time.Time, exists bool) {
	v := m.consumed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldConsumedAt returns the old "consumed_at" field's value of the PairingCode entity.
// If the PairingCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PairingCodeMutation) OldConsumedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConsumedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConsumedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConsumedAt: %w", err)
	}
	return oldValue.ConsumedAt, nil
}

// ClearConsumedAt clears the value of the "consumed_at" field.
func (m *PairingCodeMutation) ClearConsumedAt() {
	m.consumed_at = nil
	m.clearedFields[pairingcode.FieldConsumedAt] = struct{}{}
}

// ConsumedAtCleared returns if the "consumed_at" field was cleared in this mutation.
func (m *PairingCodeMutation) ConsumedAtCleared() bool {
	_, ok := m.clearedFields[pairingcode.FieldConsumedAt]
	return ok
}

// ResetConsumedAt resets all changes to the "consumed_at" field.
func (m *PairingCodeMutation) ResetConsumedAt() {
	m.consumed_at = nil
	delete(m.clearedFields, pairingcode.FieldConsumedAt)
}

// SetConsumedByPatientID sets the "consumed_by_patient_id" field.
func (m *PairingCodeMutation) SetConsumedByPatientID(u uuid.UUID) {
	m.consumed_by_patient = &u
}

// ConsumedByPatientID returns the value of the "consumed_by_patient_id" field in the mutation.
func (m *PairingCodeMutation) ConsumedByPatientID() (r uuid.UUID, exists bool) {
	v := m.consumed_by_patient
	if v == nil {
		return
	}
	return *v, true
}

// OldConsumedByPatientID returns the old "consumed_by_patient_id" field's value of the PairingCode entity.
// If the PairingCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PairingCodeMutation) OldConsumedByPatientID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConsumedByPatientID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConsumedByPatientID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConsumedByPatientID: %w", err)
	}
	return oldValue.ConsumedByPatientID, nil
}

// ClearConsumedByPatientID clears the value of the "consumed_by_patient_id" field.
func (m *PairingCodeMutation) ClearConsumedByPatientID() {
	m.consumed_by_patient = nil
	m.clearedFields[pairingcode.FieldConsumedByPatientID] = struct{}{}
}

// ConsumedByPatientIDCleared returns if the "consumed_by_patient_id" field was cleared in this mutation.
func (m *PairingCodeMutation) ConsumedByPatientIDCleared() bool {
	_, ok := m.clearedFields[pairingcode.FieldConsumedByPatientID]
	return ok
}

// ResetConsumedByPatientID resets all changes to the "consumed_by_patient_id" field.
func (m *PairingCodeMutation) ResetConsumedByPatientID() {
	m.consumed_by_patient = nil
	delete(m.clearedFields, pairingcode.FieldConsumedByPatientID)
}

// ClearDoctor clears the "doctor" edge to the Doctor entity.
func (m *PairingCodeMutation) ClearDoctor() {
	m.cleareddoctor = true
	m.clearedFields[pairingcode.FieldDoctorID] = struct{}{}
}

// DoctorCleared reports if the "doctor" edge to the Doctor entity was cleared.
func (m *PairingCodeMutation) DoctorCleared() bool {
	return m.cleareddoctor
}

// DoctorIDs returns the "doctor" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DoctorID instead. It exists only for internal usage by the builders.
func (m *PairingCodeMutation) DoctorIDs() (ids []uuid.UUID) {
	if id := m.doctor; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDoctor resets all changes to the "doctor" edge.
func (m *PairingCodeMutation) ResetDoctor() {
	m.doctor = nil
	m.cleareddoctor = false
}

// ClearConsumedByPatient clears the "consumed_by_patient" edge to the Patient entity.
func (m *PairingCodeMutation) ClearConsumedByPatient() {
	m.clearedconsumed_by_patient = true
	m.clearedFields[pairingcode.FieldConsumedByPatientID] = struct{}{}
}

// ConsumedByPatientCleared reports if the "consumed_by_patient" edge to the Patient entity was cleared.
func (m *PairingCodeMutation) ConsumedByPatientCleared() bool {
	return m.ConsumedByPatientIDCleared() || m.clearedconsumed_by_patient
}

// ConsumedByPatientIDs returns the "consumed_by_patient" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ConsumedByPatientID instead. It exists only for internal usage by the builders.
func (m *PairingCodeMutation) ConsumedByPatientIDs() (ids []uuid.UUID) {
	if id := m.consumed_by_patient; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetConsumedByPatient resets all changes to the "consumed_by_patient" edge.
func (m *PairingCodeMutation) ResetConsumedByPatient() {
	m.consumed_by_patient = nil
	m.clearedconsumed_by_patient = false
}

// Where appends a list predicates to the PairingCodeMutation builder.
func (m *PairingCodeMutation) Where(ps ...predicate.PairingCode) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PairingCodeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PairingCodeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PairingCode, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PairingCodeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PairingCodeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PairingCode).
func (m *PairingCodeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PairingCodeMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, pairingcode.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, pairingcode.FieldUpdatedAt)
	}
	if m.code != nil {
		fields = append(fields, pairingcode.FieldCode)
	}
	if m.doctor != nil {
		fields = append(fields, pairingcode.FieldDoctorID)
	}
	if m.expires_at != nil {
		fields = append(fields, pairingcode.FieldExpiresAt)
	}
	if m.consumed_at != nil {
		fields = append(fields, pairingcode.FieldConsumedAt)
	}
	if m.consumed_by_patient != nil {
		fields = append(fields, pairingcode.FieldConsumedByPatientID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PairingCodeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case pairingcode.FieldCreatedAt:
		return m.CreatedAt()
	case pairingcode.FieldUpdatedAt:
		return m.UpdatedAt()
	case pairingcode.FieldCode:
		return m.Code()
	case pairingcode.FieldDoctorID:
		return m.DoctorID()
	case pairingcode.FieldExpiresAt:
		return m.ExpiresAt()
	case pairingcode.FieldConsumedAt:
		return m.ConsumedAt()
	case pairingcode.FieldConsumedByPatientID:
		return m.ConsumedByPatientID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PairingCodeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case pairingcode.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case pairingcode.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case pairingcode.FieldCode:
		return m.OldCode(ctx)
	case pairingcode.FieldDoctorID:
		return m.OldDoctorID(ctx)
	case pairingcode.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case pairingcode.FieldConsumedAt:
		return m.OldConsumedAt(ctx)
	case pairingcode.FieldConsumedByPatientID:
		return m.OldConsumedByPatientID(ctx)
	}
	return nil, fmt.Errorf("unknown PairingCode field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PairingCodeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case pairingcode.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case pairingcode.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case pairingcode.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case pairingcode.FieldDoctorID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDoctorID(v)
		return nil
	case pairingcode.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case pairingcode.FieldConsumedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConsumedAt(v)
		return nil
	case pairingcode.FieldConsumedByPatientID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConsumedByPatientID(v)
		return nil
	}
	return fmt.Errorf("unknown PairingCode field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PairingCodeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PairingCodeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PairingCodeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PairingCode numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PairingCodeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(pairingcode.FieldConsumedAt) {
		fields = append(fields, pairingcode.FieldConsumedAt)
	}
	if m.FieldCleared(pairingcode.FieldConsumedByPatientID) {
		fields = append(fields, pairingcode.FieldConsumedByPatientID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PairingCodeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PairingCodeMutation) ClearField(name string) error {
	switch name {
	case pairingcode.FieldConsumedAt:
		m.ClearConsumedAt()
		return nil
	case pairingcode.FieldConsumedByPatientID:
		m.ClearConsumedByPatientID()
		return nil
	}
	return fmt.Errorf("unknown PairingCode nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PairingCodeMutation) ResetField(name string) error {
	switch name {
	case pairingcode.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case pairingcode.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case pairingcode.FieldCode:
		m.ResetCode()
		return nil
	case pairingcode.FieldDoctorID:
		m.ResetDoctorID()
		return nil
	case pairingcode.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case pairingcode.FieldConsumedAt:
		m.ResetConsumedAt()
		return nil
	case pairingcode.FieldConsumedByPatientID:
		m.ResetConsumedByPatientID()
		return nil
	}
	return fmt.Errorf("unknown PairingCode field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PairingCodeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.doctor != nil {
		edges = append(edges, pairingcode.EdgeDoctor)
	}
	if m.consumed_by_patient != nil {
		edges = append(edges, pairingcode.EdgeConsumedByPatient)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PairingCodeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case pairingcode.EdgeDoctor:
		if id := m.doctor; id != nil {
			return []ent.Value{*id}
		}
	case pairingcode.EdgeConsumedByPatient:
		if id := m.consumed_by_patient; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PairingCodeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PairingCodeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PairingCodeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareddoctor {
		edges = append(edges, pairingcode.EdgeDoctor)
	}
	if m.clearedconsumed_by_patient {
		edges = append(edges, pairingcode.EdgeConsumedByPatient)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PairingCodeMutation) EdgeCleared(name string) bool {
	switch name {
	case pairingcode.EdgeDoctor:
		return m.cleareddoctor
	case pairingcode.EdgeConsumedByPatient:
		return m.clearedconsumed_by_patient
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PairingCodeMutation) ClearEdge(name string) error {
	switch name {
	case pairingcode.EdgeDoctor:
		m.ClearDoctor()
		return nil
	case pairingcode.EdgeConsumedByPatient:
		m.ClearConsumedByPatient()
		return nil
	}
	return fmt.Errorf("unknown PairingCode unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PairingCodeMutation) ResetEdge(name string) error {
	switch name {
	case pairingcode.EdgeDoctor:
		m.ResetDoctor()
		return nil
	case pairingcode.EdgeConsumedByPatient:
		m.ResetConsumedByPatient()
		return nil
	}
	return fmt.Errorf("unknown PairingCode edge %s", name)
}

// PatientMutation represents an operation that mutates the Patient nodes in the graph.
type PatientMutation struct {
	config
	op                            Op
	typ                           string
	id                            *uuid.UUID
	created_at                    *time.Time
	updated_at                    *time.Time
	display_name                  *string
	birth_date                    *time.Time
	status                        *patient.Status
	email                         *string
	password_hash                 *string
	patient_code                  *string
	last_entry_at                 *time.Time
	clearedFields                 map[string]struct{}
	doctor_links                  map[uuid.UUID]struct{}
	removeddoctor_links           map[uuid.UUID]struct{}
	cleareddoctor_links           bool
	consumed_pairing_codes        map[uuid.UUID]struct{}
	removedconsumed_pairing_codes map[uuid.UUID]struct{}
	clearedconsumed_pairing_codes bool
	entries                       map[uuid.UUID]struct{}
	removedentries                map[uuid.UUID]struct{}
	clearedentries                bool
	analysis_jobs                 map[uuid.UUID]struct{}
	removedanalysis_jobs          map[uuid.UUID]struct{}
	clearedanalysis_jobs          bool
	entry_shares                  map[uuid.UUID]struct{}
	removedentry_shares           map[uuid.UUID]struct{}
	clearedentry_shares           bool
	done                          bool
	oldValue                      func(context.Context) (*Patient, error)
	predicates                    []predicate.Patient
}

var _ ent.Mutation = (*PatientMutation)(nil)

// patientOption allows management of the mutation configuration using functional options.
type patientOption func(*PatientMutation)

// newPatientMutation creates new mutation for the Patient entity.
func newPatientMutation(c config, op Op, opts ...patientOption) *PatientMutation {
	m := &PatientMutation{
		config:        c,
		op:            op,
		typ:           TypePatient,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPatientID sets the ID field of the mutation.
func withPatientID(id uuid.UUID) patientOption {
	return func(m *PatientMutation) {
		var (
			err   error
			once  sync.Once
			value *Patient
		)
		m.oldValue = func(ctx context.Context) (*Patient, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Patient.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPatient sets the old Patient of the mutation.
func withPatient(node *Patient) patientOption {
	return func(m *PatientMutation) {
		m.oldValue = func(context.Context) (*Patient, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PatientMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PatientMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Patient entities.
func (m *PatientMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PatientMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PatientMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Patient.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PatientMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PatientMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PatientMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PatientMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PatientMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PatientMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDisplayName sets the "display_name" field.
func (m *PatientMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *PatientMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *PatientMutation) ResetDisplayName() {
	m.display_name = nil
}

// SetBirthDate sets the "birth_date" field.
func (m *PatientMutation) SetBirthDate(t time.Time) {
	m.birth_date = &t
}

// BirthDate returns the value of the "birth_date" field in the mutation.
func (m *PatientMutation) BirthDate() (r time.Time, exists bool) {
	v := m.birth_date
	if v == nil {
		return
	}
	return *v, true
}

// OldBirthDate returns the old "birth_date" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldBirthDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBirthDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBirthDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBirthDate: %w", err)
	}
	return oldValue.BirthDate, nil
}

// ClearBirthDate clears the value of the "birth_date" field.
func (m *PatientMutation) ClearBirthDate() {
	m.birth_date = nil
	m.clearedFields[patient.FieldBirthDate] = struct{}{}
}

// BirthDateCleared returns if the "birth_date" field was cleared in this mutation.
func (m *PatientMutation) BirthDateCleared() bool {
	_, ok := m.clearedFields[patient.FieldBirthDate]
	return ok
}

// ResetBirthDate resets all changes to the "birth_date" field.
func (m *PatientMutation) ResetBirthDate() {
	m.birth_date = nil
	delete(m.clearedFields, patient.FieldBirthDate)
}

// SetStatus sets the "status" field.
func (m *PatientMutation) SetStatus(pa patient.Status) {
	m.status = &pa
}

// Status returns the value of the "status" field in the mutation.
func (m *PatientMutation) Status() (r patient.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldStatus(ctx context.Context) (v patient.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *PatientMutation) ResetStatus() {
	m.status = nil
}

// SetEmail sets the "email" field.
func (m *PatientMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *PatientMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldEmail(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *PatientMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[patient.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *PatientMutation) EmailCleared() bool {
	_, ok := m.clearedFields[patient.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *PatientMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, patient.FieldEmail)
}

// SetPasswordHash sets the "password_hash" field.
func (m *PatientMutation) SetPasswordHash(s string) {
	m.password_hash = &s
}

// PasswordHash returns the value of the "password_hash" field in the mutation.
func (m *PatientMutation) PasswordHash() (r string, exists bool) {
	v := m.password_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordHash returns the old "password_hash" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldPasswordHash(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordHash: %w", err)
	}
	return oldValue.PasswordHash, nil
}

// ClearPasswordHash clears the value of the "password_hash" field.
func (m *PatientMutation) ClearPasswordHash() {
	m.password_hash = nil
	m.clearedFields[patient.FieldPasswordHash] = struct{}{}
}

// PasswordHashCleared returns if the "password_hash" field was cleared in this mutation.
func (m *PatientMutation) PasswordHashCleared() bool {
	_, ok := m.clearedFields[patient.FieldPasswordHash]
	return ok
}

// ResetPasswordHash resets all changes to the "password_hash" field.
func (m *PatientMutation) ResetPasswordHash() {
	m.password_hash = nil
	delete(m.clearedFields, patient.FieldPasswordHash)
}

// SetPatientCode sets the "patient_code" field.
func (m *PatientMutation) SetPatientCode(s string) {
	m.patient_code = &s
}

// PatientCode returns the value of the "patient_code" field in the mutation.
func (m *PatientMutation) PatientCode() (r string, exists bool) {
	v := m.patient_code
	if v == nil {
		return
	}
	return *v, true
}

// OldPatientCode returns the old "patient_code" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldPatientCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPatientCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPatientCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPatientCode: %w", err)
	}
	return oldValue.PatientCode, nil
}

// ClearPatientCode clears the value of the "patient_code" field.
func (m *PatientMutation) ClearPatientCode() {
	m.patient_code = nil
	m.clearedFields[patient.FieldPatientCode] = struct{}{}
}

// PatientCodeCleared returns if the "patient_code" field was cleared in this mutation.
func (m *PatientMutation) PatientCodeCleared() bool {
	_, ok := m.clearedFields[patient.FieldPatientCode]
	return ok
}

// ResetPatientCode resets all changes to the "patient_code" field.
func (m *PatientMutation) ResetPatientCode() {
	m.patient_code = nil
	delete(m.clearedFields, patient.FieldPatientCode)
}

// SetLastEntryAt sets the "last_entry_at" field.
func (m *PatientMutation) SetLastEntryAt(t time.Time) {
	m.last_entry_at = &t
}

// LastEntryAt returns the value of the "last_entry_at" field in the mutation.
func (m *PatientMutation) LastEntryAt() (r time.Time, exists bool) {
	v := m.last_entry_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastEntryAt returns the old "last_entry_at" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldLastEntryAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastEntryAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastEntryAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastEntryAt: %w", err)
	}
	return oldValue.LastEntryAt, nil
}

// ClearLastEntryAt clears the value of the "last_entry_at" field.
func (m *PatientMutation) ClearLastEntryAt() {
	m.last_entry_at = nil
	m.clearedFields[patient.FieldLastEntryAt] = struct{}{}
}

// LastEntryAtCleared returns if the "last_entry_at" field was cleared in this mutation.
func (m *PatientMutation) LastEntryAtCleared() bool {
	_, ok := m.clearedFields[patient.FieldLastEntryAt]
	return ok
}

// ResetLastEntryAt resets all changes to the "last_entry_at" field.
func (m *PatientMutation) ResetLastEntryAt() {
	m.last_entry_at = nil
	delete(m.clearedFields, patient.FieldLastEntryAt)
}

// AddDoctorLinkIDs adds the "doctor_links" edge to the DoctorPatientLink entity by ids.
func (m *PatientMutation) AddDoctorLinkIDs(ids ...uuid.UUID) {
	if m.doctor_links == nil {
		m.doctor_links = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.doctor_links[ids[i]] = struct{}{}
	}
}

// ClearDoctorLinks clears the "doctor_links" edge to the DoctorPatientLink entity.
func (m *PatientMutation) ClearDoctorLinks() {
	m.cleareddoctor_links = true
}

// DoctorLinksCleared reports if the "doctor_links" edge to the DoctorPatientLink entity was cleared.
func (m *PatientMutation) DoctorLinksCleared() bool {
	return m.cleareddoctor_links
}

// RemoveDoctorLinkIDs removes the "doctor_links" edge to the DoctorPatientLink entity by IDs.
func (m *PatientMutation) RemoveDoctorLinkIDs(ids ...uuid.UUID) {
	if m.removeddoctor_links == nil {
		m.removeddoctor_links = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.doctor_links, ids[i])
		m.removeddoctor_links[ids[i]] = struct{}{}
	}
}

// RemovedDoctorLinks returns the removed IDs of the "doctor_links" edge to the DoctorPatientLink entity.
func (m *PatientMutation) RemovedDoctorLinksIDs() (ids []uuid.UUID) {
	for id := range m.removeddoctor_links {
		ids = append(ids, id)
	}
	return
}

// DoctorLinksIDs returns the "doctor_links" edge IDs in the mutation.
func (m *PatientMutation) DoctorLinksIDs() (ids []uuid.UUID) {
	for id := range m.doctor_links {
		ids = append(ids, id)
	}
	return
}

// ResetDoctorLinks resets all changes to the "doctor_links" edge.
func (m *PatientMutation) ResetDoctorLinks() {
	m.doctor_links = nil
	m.cleareddoctor_links = false
	m.removeddoctor_links = nil
}

// AddConsumedPairingCodeIDs adds the "consumed_pairing_codes" edge to the PairingCode entity by ids.
func (m *PatientMutation) AddConsumedPairingCodeIDs(ids ...uuid.UUID) {
	if m.consumed_pairing_codes == nil {
		m.consumed_pairing_codes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.consumed_pairing_codes[ids[i]] = struct{}{}
	}
}

// ClearConsumedPairingCodes clears the "consumed_pairing_codes" edge to the PairingCode entity.
func (m *PatientMutation) ClearConsumedPairingCodes() {
	m.clearedconsumed_pairing_codes = true
}

// ConsumedPairingCodesCleared reports if the "consumed_pairing_codes" edge to the PairingCode entity was cleared.
func (m *PatientMutation) ConsumedPairingCodesCleared() bool {
	return m.clearedconsumed_pairing_codes
}

// RemoveConsumedPairingCodeIDs removes the "consumed_pairing_codes" edge to the PairingCode entity by IDs.
func (m *PatientMutation) RemoveConsumedPairingCodeIDs(ids ...uuid.UUID) {
	if m.removedconsumed_pairing_codes == nil {
		m.removedconsumed_pairing_codes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.consumed_pairing_codes, ids[i])
		m.removedconsumed_pairing_codes[ids[i]] = struct{}{}
	}
}

// RemovedConsumedPairingCodes returns the removed IDs of the "consumed_pairing_codes" edge to the PairingCode entity.
func (m *PatientMutation) RemovedConsumedPairingCodesIDs() (ids []uuid.UUID) {
	for id := range m.removedconsumed_pairing_codes {
		ids = append(ids, id)
	}
	return
}

// ConsumedPairingCodesIDs returns the "consumed_pairing_codes" edge IDs in the mutation.
func (m *PatientMutation) ConsumedPairingCodesIDs() (ids []uuid.UUID) {
	for id := range m.consumed_pairing_codes {
		ids = append(ids, id)
	}
	return
}

// ResetConsumedPairingCodes resets all changes to the "consumed_pairing_codes" edge.
func (m *PatientMutation) ResetConsumedPairingCodes() {
	m.consumed_pairing_codes = nil
	m.clearedconsumed_pairing_codes = false
	m.removedconsumed_pairing_codes = nil
}

// AddEntryIDs adds the "entries" edge to the Entry entity by ids.
func (m *PatientMutation) AddEntryIDs(ids ...uuid.UUID) {
	if m.entries == nil {
		m.entries = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.entries[ids[i]] = struct{}{}
	}
}

// ClearEntries clears the "entries" edge to the Entry entity.
func (m *PatientMutation) ClearEntries() {
	m.clearedentries = true
}

// EntriesCleared reports if the "entries" edge to the Entry entity was cleared.
func (m *PatientMutation) EntriesCleared() bool {
	return m.clearedentries
}

// RemoveEntryIDs removes the "entries" edge to the Entry entity by IDs.
func (m *PatientMutation) RemoveEntryIDs(ids ...uuid.UUID) {
	if m.removedentries == nil {
		m.removedentries = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.entries, ids[i])
		m.removedentries[ids[i]] = struct{}{}
	}
}

// RemovedEntries returns the removed IDs of the "entries" edge to the Entry entity.
func (m *PatientMutation) RemovedEntriesIDs() (ids []uuid.UUID) {
	for id := range m.removedentries {
		ids = append(ids, id)
	}
	return
}

// EntriesIDs returns the "entries" edge IDs in the mutation.
func (m *PatientMutation) EntriesIDs() (ids []uuid.UUID) {
	for id := range m.entries {
		ids = append(ids, id)
	}
	return
}

// ResetEntries resets all changes to the "entries" edge.
func (m *PatientMutation) ResetEntries() {
	m.entries = nil
	m.clearedentries = false
	m.removedentries = nil
}

// AddAnalysisJobIDs adds the "analysis_jobs" edge to the AnalysisJob entity by ids.
func (m *PatientMutation) AddAnalysisJobIDs(ids ...uuid.UUID) {
	if m.analysis_jobs == nil {
		m.analysis_jobs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.analysis_jobs[ids[i]] = struct{}{}
	}
}

// ClearAnalysisJobs clears the "analysis_jobs" edge to the AnalysisJob entity.
func (m *PatientMutation) ClearAnalysisJobs() {
	m.clearedanalysis_jobs = true
}

// AnalysisJobsCleared reports if the "analysis_jobs" edge to the AnalysisJob entity was cleared.
func (m *PatientMutation) AnalysisJobsCleared() bool {
	return m.clearedanalysis_jobs
}

// RemoveAnalysisJobIDs removes the "analysis_jobs" edge to the AnalysisJob entity by IDs.
func (m *PatientMutation) RemoveAnalysisJobIDs(ids ...uuid.UUID) {
	if m.removedanalysis_jobs == nil {
		m.removedanalysis_jobs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.analysis_jobs, ids[i])
		m.removedanalysis_jobs[ids[i]] = struct{}{}
	}
}

// RemovedAnalysisJobs returns the removed IDs of the "analysis_jobs" edge to the AnalysisJob entity.
func (m *PatientMutation) RemovedAnalysisJobsIDs() (ids []uuid.UUID) {
	for id := range m.removedanalysis_jobs {
		ids = append(ids, id)
	}
	return
}

// AnalysisJobsIDs returns the "analysis_jobs" edge IDs in the mutation.
func (m *PatientMutation) AnalysisJobsIDs() (ids []uuid.UUID) {
	for id := range m.analysis_jobs {
		ids = append(ids, id)
	}
	return
}

// ResetAnalysisJobs resets all changes to the "analysis_jobs" edge.
func (m *PatientMutation) ResetAnalysisJobs() {
	m.analysis_jobs = nil
	m.clearedanalysis_jobs = false
	m.removedanalysis_jobs = nil
}

// AddEntryShareIDs adds the "entry_shares" edge to the EntryShare entity by ids.
func (m *PatientMutation) AddEntryShareIDs(ids ...uuid.UUID) {
	if m.entry_shares == nil {
		m.entry_shares = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.entry_shares[ids[i]] = struct{}{}
	}
}

// ClearEntryShares clears the "entry_shares" edge to the EntryShare entity.
func (m *PatientMutation) ClearEntryShares() {
	m.clearedentry_shares = true
}

// EntrySharesCleared reports if the "entry_shares" edge to the EntryShare entity was cleared.
func (m *PatientMutation) EntrySharesCleared() bool {
	return m.clearedentry_shares
}

// RemoveEntryShareIDs removes the "entry_shares" edge to the EntryShare entity by IDs.
func (m *PatientMutation) RemoveEntryShareIDs(ids ...uuid.UUID) {
	if m.removedentry_shares == nil {
		m.removedentry_shares = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.entry_shares, ids[i])
		m.removedentry_shares[ids[i]] = struct{}{}
	}
}

// RemovedEntryShares returns the removed IDs of the "entry_shares" edge to the EntryShare entity.
func (m *PatientMutation) RemovedEntrySharesIDs() (ids []uuid.UUID) {
	for id := range m.removedentry_shares {
		ids = append(ids, id)
	}
	return
}

// EntrySharesIDs returns the "entry_shares" edge IDs in the mutation.
func (m *PatientMutation) EntrySharesIDs() (ids []uuid.UUID) {
	for id := range m.entry_shares {
		ids = append(ids, id)
	}
	return
}

// ResetEntryShares resets all changes to the "entry_shares" edge.
func (m *PatientMutation) ResetEntryShares() {
	m.entry_shares = nil
	m.clearedentry_shares = false
	m.removedentry_shares = nil
}

// Where appends a list predicates to the PatientMutation builder.
func (m *PatientMutation) Where(ps ...predicate.Patient) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PatientMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PatientMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Patient, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PatientMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PatientMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Patient).
func (m *PatientMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PatientMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, patient.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, patient.FieldUpdatedAt)
	}
	if m.display_name != nil {
		fields = append(fields, patient.FieldDisplayName)
	}
	if m.birth_date != nil {
		fields = append(fields, patient.FieldBirthDate)
	}
	if m.status != nil {
		fields = append(fields, patient.FieldStatus)
	}
	if m.email != nil {
		fields = append(fields, patient.FieldEmail)
	}
	if m.password_hash != nil {
		fields = append(fields, patient.FieldPasswordHash)
	}
	if m.patient_code != nil {
		fields = append(fields, patient.FieldPatientCode)
	}
	if m.last_entry_at != nil {
		fields = append(fields, patient.FieldLastEntryAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PatientMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case patient.FieldCreatedAt:
		return m.CreatedAt()
	case patient.FieldUpdatedAt:
		return m.UpdatedAt()
	case patient.FieldDisplayName:
		return m.DisplayName()
	case patient.FieldBirthDate:
		return m.BirthDate()
	case patient.FieldStatus:
		return m.Status()
	case patient.FieldEmail:
		return m.Email()
	case patient.FieldPasswordHash:
		return m.PasswordHash()
	case patient.FieldPatientCode:
		return m.PatientCode()
	case patient.FieldLastEntryAt:
		return m.LastEntryAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PatientMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case patient.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case patient.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case patient.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case patient.FieldBirthDate:
		return m.OldBirthDate(ctx)
	case patient.FieldStatus:
		return m.OldStatus(ctx)
	case patient.FieldEmail:
		return m.OldEmail(ctx)
	case patient.FieldPasswordHash:
		return m.OldPasswordHash(ctx)
	case patient.FieldPatientCode:
		return m.OldPatientCode(ctx)
	case patient.FieldLastEntryAt:
		return m.OldLastEntryAt(ctx)
	}
	return nil, fmt.Errorf("unknown Patient field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PatientMutation) SetField(name string, value ent.Value) error {
	switch name {
	case patient.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case patient.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case patient.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case patient.FieldBirthDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBirthDate(v)
		return nil
	case patient.FieldStatus:
		v, ok := value.(patient.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case patient.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case patient.FieldPasswordHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordHash(v)
		return nil
	case patient.FieldPatientCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPatientCode(v)
		return nil
	case patient.FieldLastEntryAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastEntryAt(v)
		return nil
	}
	return fmt.Errorf("unknown Patient field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PatientMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PatientMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PatientMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Patient numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PatientMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(patient.FieldBirthDate) {
		fields = append(fields, patient.FieldBirthDate)
	}
	if m.FieldCleared(patient.FieldEmail) {
		fields = append(fields, patient.FieldEmail)
	}
	if m.FieldCleared(patient.FieldPasswordHash) {
		fields = append(fields, patient.FieldPasswordHash)
	}
	if m.FieldCleared(patient.FieldPatientCode) {
		fields = append(fields, patient.FieldPatientCode)
	}
	if m.FieldCleared(patient.FieldLastEntryAt) {
		fields = append(fields, patient.FieldLastEntryAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PatientMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PatientMutation) ClearField(name string) error {
	switch name {
	case patient.FieldBirthDate:
		m.ClearBirthDate()
		return nil
	case patient.FieldEmail:
		m.ClearEmail()
		return nil
	case patient.FieldPasswordHash:
		m.ClearPasswordHash()
		return nil
	case patient.FieldPatientCode:
		m.ClearPatientCode()
		return nil
	case patient.FieldLastEntryAt:
		m.ClearLastEntryAt()
		return nil
	}
	return fmt.Errorf("unknown Patient nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PatientMutation) ResetField(name string) error {
	switch name {
	case patient.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case patient.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case patient.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case patient.FieldBirthDate:
		m.ResetBirthDate()
		return nil
	case patient.FieldStatus:
		m.ResetStatus()
		return nil
	case patient.FieldEmail:
		m.ResetEmail()
		return nil
	case patient.FieldPasswordHash:
		m.ResetPasswordHash()
		return nil
	case patient.FieldPatientCode:
		m.ResetPatientCode()
		return nil
	case patient.FieldLastEntryAt:
		m.ResetLastEntryAt()
		return nil
	}
	return fmt.Errorf("unknown Patient field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PatientMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.doctor_links != nil {
		edges = append(edges, patient.EdgeDoctorLinks)
	}
	if m.consumed_pairing_codes != nil {
		edges = append(edges, patient.EdgeConsumedPairingCodes)
	}
	if m.entries != nil {
		edges = append(edges, patient.EdgeEntries)
	}
	if m.analysis_jobs != nil {
		edges = append(edges, patient.EdgeAnalysisJobs)
	}
	if m.entry_shares != nil {
		edges = append(edges, patient.EdgeEntryShares)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PatientMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case patient.EdgeDoctorLinks:
		ids := make([]ent.Value, 0, len(m.doctor_links))
		for id := range m.doctor_links {
			ids = append(ids, id)
		}
		return ids
	case patient.EdgeConsumedPairingCodes:
		ids := make([]ent.Value, 0, len(m.consumed_pairing_codes))
		for id := range m.consumed_pairing_codes {
			ids = append(ids, id)
		}
		return ids
	case patient.EdgeEntries:
		ids := make([]ent.Value, 0, len(m.entries))
		for id := range m.entries {
			ids = append(ids, id)
		}
		return ids
	case patient.EdgeAnalysisJobs:
		ids := make([]ent.Value, 0, len(m.analysis_jobs))
		for id := range m.analysis_jobs {
			ids = append(ids, id)
		}
		return ids
	case patient.EdgeEntryShares:
		ids := make([]ent.Value, 0, len(m.entry_shares))
		for id := range m.entry_shares {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PatientMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removeddoctor_links != nil {
		edges = append(edges, patient.EdgeDoctorLinks)
	}
	if m.removedconsumed_pairing_codes != nil {
		edges = append(edges, patient.EdgeConsumedPairingCodes)
	}
	if m.removedentries != nil {
		edges = append(edges, patient.EdgeEntries)
	}
	if m.removedanalysis_jobs != nil {
		edges = append(edges, patient.EdgeAnalysisJobs)
	}
	if m.removedentry_shares != nil {
		edges = append(edges, patient.EdgeEntryShares)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PatientMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case patient.EdgeDoctorLinks:
		ids := make([]ent.Value, 0, len(m.removeddoctor_links))
		for id := range m.removeddoctor_links {
			ids = append(ids, id)
		}
		return ids
	case patient.EdgeConsumedPairingCodes:
		ids := make([]ent.Value, 0, len(m.removedconsumed_pairing_codes))
		for id := range m.removedconsumed_pairing_codes {
			ids = append(ids, id)
		}
		return ids
	case patient.EdgeEntries:
		ids := make([]ent.Value, 0, len(m.removedentries))
		for id := range m.removedentries {
			ids = append(ids, id)
		}
		return ids
	case patient.EdgeAnalysisJobs:
		ids := make([]ent.Value, 0, len(m.removedanalysis_jobs))
		for id := range m.removedanalysis_jobs {
			ids = append(ids, id)
		}
		return ids
	case patient.EdgeEntryShares:
		ids := make([]ent.Value, 0, len(m.removedentry_shares))
		for id := range m.removedentry_shares {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PatientMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.cleareddoctor_links {
		edges = append(edges, patient.EdgeDoctorLinks)
	}
	if m.clearedconsumed_pairing_codes {
		edges = append(edges, patient.EdgeConsumedPairingCodes)
	}
	if m.clearedentries {
		edges = append(edges, patient.EdgeEntries)
	}
	if m.clearedanalysis_jobs {
		edges = append(edges, patient.EdgeAnalysisJobs)
	}
	if m.clearedentry_shares {
		edges = append(edges, patient.EdgeEntryShares)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PatientMutation) EdgeCleared(name string) bool {
	switch name {
	case patient.EdgeDoctorLinks:
		return m.cleareddoctor_links
	case patient.EdgeConsumedPairingCodes:
		return m.clearedconsumed_pairing_codes
	case patient.EdgeEntries:
		return m.clearedentries
	case patient.EdgeAnalysisJobs:
		return m.clearedanalysis_jobs
	case patient.EdgeEntryShares:
		return m.clearedentry_shares
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PatientMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Patient unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PatientMutation) ResetEdge(name string) error {
	switch name {
	case patient.EdgeDoctorLinks:
		m.ResetDoctorLinks()
		return nil
	case patient.EdgeConsumedPairingCodes:
		m.ResetConsumedPairingCodes()
		return nil
	case patient.EdgeEntries:
		m.ResetEntries()
		return nil
	case patient.EdgeAnalysisJobs:
		m.ResetAnalysisJobs()
		return nil
	case patient.EdgeEntryShares:
		m.ResetEntryShares()
		return nil
	}
	return fmt.Errorf("unknown Patient edge %s", name)
}

// PracticeMutation represents an operation that mutates the Practice nodes in the graph.
type PracticeMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	created_at     *time.Time
	updated_at     *time.Time
	name           *string
	address        *string
	clearedFields  map[string]struct{}
	doctors        map[uuid.UUID]struct{}
	removeddoctors map[uuid.UUID]struct{}
	cleareddoctors bool
	done           bool
	oldValue       func(context.Context) (*Practice, error)
	predicates     []predicate.Practice
}

var _ ent.Mutation = (*PracticeMutation)(nil)

// practiceOption allows management of the mutation configuration using functional options.
type practiceOption func(*PracticeMutation)

// newPracticeMutation creates new mutation for the Practice entity.
func newPracticeMutation(c config, op Op, opts ...practiceOption) *PracticeMutation {
	m := &PracticeMutation{
		config:        c,
		op:            op,
		typ:           TypePractice,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPracticeID sets the ID field of the mutation.
func withPracticeID(id uuid.UUID) practiceOption {
	return func(m *PracticeMutation) {
		var (
			err   error
			once  sync.Once
			value *Practice
		)
		m.oldValue = func(ctx context.Context) (*Practice, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Practice.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPractice sets the old Practice of the mutation.
func withPractice(node *Practice) practiceOption {
	return func(m *PracticeMutation) {
		m.oldValue = func(context.Context) (*Practice, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PracticeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PracticeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Practice entities.
func (m *PracticeMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PracticeMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PracticeMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Practice.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PracticeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PracticeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Practice entity.
// If the Practice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PracticeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PracticeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PracticeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PracticeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Practice entity.
// If the Practice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PracticeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PracticeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *PracticeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PracticeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Practice entity.
// If the Practice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PracticeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PracticeMutation) ResetName() {
	m.name = nil
}

// SetAddress sets the "address" field.
func (m *PracticeMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *PracticeMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Practice entity.
// If the Practice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PracticeMutation) OldAddress(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ClearAddress clears the value of the "address" field.
func (m *PracticeMutation) ClearAddress() {
	m.address = nil
	m.clearedFields[practice.FieldAddress] = struct{}{}
}

// AddressCleared returns if the "address" field was cleared in this mutation.
func (m *PracticeMutation) AddressCleared() bool {
	_, ok := m.clearedFields[practice.FieldAddress]
	return ok
}

// ResetAddress resets all changes to the "address" field.
func (m *PracticeMutation) ResetAddress() {
	m.address = nil
	delete(m.clearedFields, practice.FieldAddress)
}

// AddDoctorIDs adds the "doctors" edge to the Doctor entity by ids.
func (m *PracticeMutation) AddDoctorIDs(ids ...uuid.UUID) {
	if m.doctors == nil {
		m.doctors = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.doctors[ids[i]] = struct{}{}
	}
}

// ClearDoctors clears the "doctors" edge to the Doctor entity.
func (m *PracticeMutation) ClearDoctors() {
	m.cleareddoctors = true
}

// DoctorsCleared reports if the "doctors" edge to the Doctor entity was cleared.
func (m *PracticeMutation) DoctorsCleared() bool {
	return m.cleareddoctors
}

// RemoveDoctorIDs removes the "doctors" edge to the Doctor entity by IDs.
func (m *PracticeMutation) RemoveDoctorIDs(ids ...uuid.UUID) {
	if m.removeddoctors == nil {
		m.removeddoctors = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.doctors, ids[i])
		m.removeddoctors[ids[i]] = struct{}{}
	}
}

// RemovedDoctors returns the removed IDs of the "doctors" edge to the Doctor entity.
func (m *PracticeMutation) RemovedDoctorsIDs() (ids []uuid.UUID) {
	for id := range m.removeddoctors {
		ids = append(ids, id)
	}
	return
}

// DoctorsIDs returns the "doctors" edge IDs in the mutation.
func (m *PracticeMutation) DoctorsIDs() (ids []uuid.UUID) {
	for id := range m.doctors {
		ids = append(ids, id)
	}
	return
}

// ResetDoctors resets all changes to the "doctors" edge.
func (m *PracticeMutation) ResetDoctors() {
	m.doctors = nil
	m.cleareddoctors = false
	m.removeddoctors = nil
}

// Where appends a list predicates to the PracticeMutation builder.
func (m *PracticeMutation) Where(ps ...predicate.Practice) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PracticeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PracticeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Practice, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PracticeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PracticeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Practice).
func (m *PracticeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PracticeMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, practice.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, practice.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, practice.FieldName)
	}
	if m.address != nil {
		fields = append(fields, practice.FieldAddress)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PracticeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case practice.FieldCreatedAt:
		return m.CreatedAt()
	case practice.FieldUpdatedAt:
		return m.UpdatedAt()
	case practice.FieldName:
		return m.Name()
	case practice.FieldAddress:
		return m.Address()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PracticeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case practice.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case practice.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case practice.FieldName:
		return m.OldName(ctx)
	case practice.FieldAddress:
		return m.OldAddress(ctx)
	}
	return nil, fmt.Errorf("unknown Practice field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PracticeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case practice.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case practice.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case practice.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case practice.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	}
	return fmt.Errorf("unknown Practice field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PracticeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PracticeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PracticeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Practice numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PracticeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(practice.FieldAddress) {
		fields = append(fields, practice.FieldAddress)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PracticeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PracticeMutation) ClearField(name string) error {
	switch name {
	case practice.FieldAddress:
		m.ClearAddress()
		return nil
	}
	return fmt.Errorf("unknown Practice nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PracticeMutation) ResetField(name string) error {
	switch name {
	case practice.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case practice.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case practice.FieldName:
		m.ResetName()
		return nil
	case practice.FieldAddress:
		m.ResetAddress()
		return nil
	}
	return fmt.Errorf("unknown Practice field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PracticeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.doctors != nil {
		edges = append(edges, practice.EdgeDoctors)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PracticeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case practice.EdgeDoctors:
		ids := make([]ent.Value, 0, len(m.doctors))
		for id := range m.doctors {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PracticeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removeddoctors != nil {
		edges = append(edges, practice.EdgeDoctors)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PracticeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case practice.EdgeDoctors:
		ids := make([]ent.Value, 0, len(m.removeddoctors))
		for id := range m.removeddoctors {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PracticeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareddoctors {
		edges = append(edges, practice.EdgeDoctors)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PracticeMutation) EdgeCleared(name string) bool {
	switch name {
	case practice.EdgeDoctors:
		return m.cleareddoctors
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PracticeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Practice unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PracticeMutation) ResetEdge(name string) error {
	switch name {
	case practice.EdgeDoctors:
		m.ResetDoctors()
		return nil
	}
	return fmt.Errorf("unknown Practice edge %s", name)
}

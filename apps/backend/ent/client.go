// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"backend/ent/migrate"

	"backend/ent/analysisjob"
	"backend/ent/comment"
	"backend/ent/doctor"
	"backend/ent/doctorpatientlink"
	"backend/ent/entry"
	"backend/ent/entryshare"
	"backend/ent/pairingcode"
	"backend/ent/patient"
	"backend/ent/practice"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/google/uuid"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// AnalysisJob is the client for interacting with the AnalysisJob builders.
	AnalysisJob *AnalysisJobClient
	// Comment is the client for interacting with the Comment builders.
	Comment *CommentClient
	// Doctor is the client for interacting with the Doctor builders.
	Doctor *DoctorClient
	// DoctorPatientLink is the client for interacting with the DoctorPatientLink builders.
	DoctorPatientLink *DoctorPatientLinkClient
	// Entry is the client for interacting with the Entry builders.
	Entry *EntryClient
	// EntryShare is the client for interacting with the EntryShare builders.
	EntryShare *EntryShareClient
	// PairingCode is the client for interacting with the PairingCode builders.
	PairingCode *PairingCodeClient
	// Patient is the client for interacting with the Patient builders.
	Patient *PatientClient
	// Practice is the client for interacting with the Practice builders.
	Practice *PracticeClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.AnalysisJob = NewAnalysisJobClient(c.config)
	c.Comment = NewCommentClient(c.config)
	c.Doctor = NewDoctorClient(c.config)
	c.DoctorPatientLink = NewDoctorPatientLinkClient(c.config)
	c.Entry = NewEntryClient(c.config)
	c.EntryShare = NewEntryShareClient(c.config)
	c.PairingCode = NewPairingCodeClient(c.config)
	c.Patient = NewPatientClient(c.config)
	c.Practice = NewPracticeClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:               ctx,
		config:            cfg,
		AnalysisJob:       NewAnalysisJobClient(cfg),
		Comment:           NewCommentClient(cfg),
		Doctor:            NewDoctorClient(cfg),
		DoctorPatientLink: NewDoctorPatientLinkClient(cfg),
		Entry:             NewEntryClient(cfg),
		EntryShare:        NewEntryShareClient(cfg),
		PairingCode:       NewPairingCodeClient(cfg),
		Patient:           NewPatientClient(cfg),
		Practice:          NewPracticeClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:               ctx,
		config:            cfg,
		AnalysisJob:       NewAnalysisJobClient(cfg),
		Comment:           NewCommentClient(cfg),
		Doctor:            NewDoctorClient(cfg),
		DoctorPatientLink: NewDoctorPatientLinkClient(cfg),
		Entry:             NewEntryClient(cfg),
		EntryShare:        NewEntryShareClient(cfg),
		PairingCode:       NewPairingCodeClient(cfg),
		Patient:           NewPatientClient(cfg),
		Practice:          NewPracticeClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		AnalysisJob.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.AnalysisJob, c.Comment, c.Doctor, c.DoctorPatientLink, c.Entry, c.EntryShare,
		c.PairingCode, c.Patient, c.Practice,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.AnalysisJob, c.Comment, c.Doctor, c.DoctorPatientLink, c.Entry, c.EntryShare,
		c.PairingCode, c.Patient, c.Practice,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *AnalysisJobMutation:
		return c.AnalysisJob.mutate(ctx, m)
	case *CommentMutation:
		return c.Comment.mutate(ctx, m)
	case *DoctorMutation:
		return c.Doctor.mutate(ctx, m)
	case *DoctorPatientLinkMutation:
		return c.DoctorPatientLink.mutate(ctx, m)
	case *EntryMutation:
		return c.Entry.mutate(ctx, m)
	case *EntryShareMutation:
		return c.EntryShare.mutate(ctx, m)
	case *PairingCodeMutation:
		return c.PairingCode.mutate(ctx, m)
	case *PatientMutation:
		return c.Patient.mutate(ctx, m)
	case *PracticeMutation:
		return c.Practice.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// AnalysisJobClient is a client for the AnalysisJob schema.
type AnalysisJobClient struct {
	config
}

// NewAnalysisJobClient returns a client for the AnalysisJob from the given config.
func NewAnalysisJobClient(c config) *AnalysisJobClient {
	return &AnalysisJobClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `analysisjob.Hooks(f(g(h())))`.
func (c *AnalysisJobClient) Use(hooks ...Hook) {
	c.hooks.AnalysisJob = append(c.hooks.AnalysisJob, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `analysisjob.Intercept(f(g(h())))`.
func (c *AnalysisJobClient) Intercept(interceptors ...Interceptor) {
	c.inters.AnalysisJob = append(c.inters.AnalysisJob, interceptors...)
}

// Create returns a builder for creating a AnalysisJob entity.
func (c *AnalysisJobClient) Create() *AnalysisJobCreate {
	mutation := newAnalysisJobMutation(c.config, OpCreate)
	return &AnalysisJobCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AnalysisJob entities.
func (c *AnalysisJobClient) CreateBulk(builders ...*AnalysisJobCreate) *AnalysisJobCreateBulk {
	return &AnalysisJobCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AnalysisJobClient) MapCreateBulk(slice any, setFunc func(*AnalysisJobCreate, int)) *AnalysisJobCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AnalysisJobCreateBulk{err: fmt.Errorf("calling to AnalysisJobClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AnalysisJobCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AnalysisJobCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AnalysisJob.
func (c *AnalysisJobClient) Update() *AnalysisJobUpdate {
	mutation := newAnalysisJobMutation(c.config, OpUpdate)
	return &AnalysisJobUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AnalysisJobClient) UpdateOne(_m *AnalysisJob) *AnalysisJobUpdateOne {
	mutation := newAnalysisJobMutation(c.config, OpUpdateOne, withAnalysisJob(_m))
	return &AnalysisJobUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AnalysisJobClient) UpdateOneID(id uuid.UUID) *AnalysisJobUpdateOne {
	mutation := newAnalysisJobMutation(c.config, OpUpdateOne, withAnalysisJobID(id))
	return &AnalysisJobUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AnalysisJob.
func (c *AnalysisJobClient) Delete() *AnalysisJobDelete {
	mutation := newAnalysisJobMutation(c.config, OpDelete)
	return &AnalysisJobDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AnalysisJobClient) DeleteOne(_m *AnalysisJob) *AnalysisJobDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AnalysisJobClient) DeleteOneID(id uuid.UUID) *AnalysisJobDeleteOne {
	builder := c.Delete().Where(analysisjob.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AnalysisJobDeleteOne{builder}
}

// Query returns a query builder for AnalysisJob.
func (c *AnalysisJobClient) Query() *AnalysisJobQuery {
	return &AnalysisJobQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAnalysisJob},
		inters: c.Interceptors(),
	}
}

// Get returns a AnalysisJob entity by its id.
func (c *AnalysisJobClient) Get(ctx context.Context, id uuid.UUID) (*AnalysisJob, error) {
	return c.Query().Where(analysisjob.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AnalysisJobClient) GetX(ctx context.Context, id uuid.UUID) *AnalysisJob {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPatient queries the patient edge of a AnalysisJob.
func (c *AnalysisJobClient) QueryPatient(_m *AnalysisJob) *PatientQuery {
	query := (&PatientClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(analysisjob.Table, analysisjob.FieldID, id),
			sqlgraph.To(patient.Table, patient.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, analysisjob.PatientTable, analysisjob.PatientColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCreatedByDoctor queries the created_by_doctor edge of a AnalysisJob.
func (c *AnalysisJobClient) QueryCreatedByDoctor(_m *AnalysisJob) *DoctorQuery {
	query := (&DoctorClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(analysisjob.Table, analysisjob.FieldID, id),
			sqlgraph.To(doctor.Table, doctor.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, analysisjob.CreatedByDoctorTable, analysisjob.CreatedByDoctorColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEntry queries the entry edge of a AnalysisJob.
func (c *AnalysisJobClient) QueryEntry(_m *AnalysisJob) *EntryQuery {
	query := (&EntryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(analysisjob.Table, analysisjob.FieldID, id),
			sqlgraph.To(entry.Table, entry.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, analysisjob.EntryTable, analysisjob.EntryColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AnalysisJobClient) Hooks() []Hook {
	return c.hooks.AnalysisJob
}

// Interceptors returns the client interceptors.
func (c *AnalysisJobClient) Interceptors() []Interceptor {
	return c.inters.AnalysisJob
}

func (c *AnalysisJobClient) mutate(ctx context.Context, m *AnalysisJobMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AnalysisJobCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AnalysisJobUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AnalysisJobUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AnalysisJobDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AnalysisJob mutation op: %q", m.Op())
	}
}

// CommentClient is a client for the Comment schema.
type CommentClient struct {
	config
}

// NewCommentClient returns a client for the Comment from the given config.
func NewCommentClient(c config) *CommentClient {
	return &CommentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `comment.Hooks(f(g(h())))`.
func (c *CommentClient) Use(hooks ...Hook) {
	c.hooks.Comment = append(c.hooks.Comment, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `comment.Intercept(f(g(h())))`.
func (c *CommentClient) Intercept(interceptors ...Interceptor) {
	c.inters.Comment = append(c.inters.Comment, interceptors...)
}

// Create returns a builder for creating a Comment entity.
func (c *CommentClient) Create() *CommentCreate {
	mutation := newCommentMutation(c.config, OpCreate)
	return &CommentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Comment entities.
func (c *CommentClient) CreateBulk(builders ...*CommentCreate) *CommentCreateBulk {
	return &CommentCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CommentClient) MapCreateBulk(slice any, setFunc func(*CommentCreate, int)) *CommentCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CommentCreateBulk{err: fmt.Errorf("calling to CommentClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CommentCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CommentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Comment.
func (c *CommentClient) Update() *CommentUpdate {
	mutation := newCommentMutation(c.config, OpUpdate)
	return &CommentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CommentClient) UpdateOne(_m *Comment) *CommentUpdateOne {
	mutation := newCommentMutation(c.config, OpUpdateOne, withComment(_m))
	return &CommentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CommentClient) UpdateOneID(id uuid.UUID) *CommentUpdateOne {
	mutation := newCommentMutation(c.config, OpUpdateOne, withCommentID(id))
	return &CommentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Comment.
func (c *CommentClient) Delete() *CommentDelete {
	mutation := newCommentMutation(c.config, OpDelete)
	return &CommentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CommentClient) DeleteOne(_m *Comment) *CommentDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CommentClient) DeleteOneID(id uuid.UUID) *CommentDeleteOne {
	builder := c.Delete().Where(comment.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CommentDeleteOne{builder}
}

// Query returns a query builder for Comment.
func (c *CommentClient) Query() *CommentQuery {
	return &CommentQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeComment},
		inters: c.Interceptors(),
	}
}

// Get returns a Comment entity by its id.
func (c *CommentClient) Get(ctx context.Context, id uuid.UUID) (*Comment, error) {
	return c.Query().Where(comment.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CommentClient) GetX(ctx context.Context, id uuid.UUID) *Comment {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryEntry queries the entry edge of a Comment.
func (c *CommentClient) QueryEntry(_m *Comment) *EntryQuery {
	query := (&EntryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(comment.Table, comment.FieldID, id),
			sqlgraph.To(entry.Table, entry.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, comment.EntryTable, comment.EntryColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAuthor queries the author edge of a Comment.
func (c *CommentClient) QueryAuthor(_m *Comment) *DoctorQuery {
	query := (&DoctorClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(comment.Table, comment.FieldID, id),
			sqlgraph.To(doctor.Table, doctor.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, comment.AuthorTable, comment.AuthorColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CommentClient) Hooks() []Hook {
	return c.hooks.Comment
}

// Interceptors returns the client interceptors.
func (c *CommentClient) Interceptors() []Interceptor {
	return c.inters.Comment
}

func (c *CommentClient) mutate(ctx context.Context, m *CommentMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CommentCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CommentUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CommentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CommentDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Comment mutation op: %q", m.Op())
	}
}

// DoctorClient is a client for the Doctor schema.
type DoctorClient struct {
	config
}

// NewDoctorClient returns a client for the Doctor from the given config.
func NewDoctorClient(c config) *DoctorClient {
	return &DoctorClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `doctor.Hooks(f(g(h())))`.
func (c *DoctorClient) Use(hooks ...Hook) {
	c.hooks.Doctor = append(c.hooks.Doctor, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `doctor.Intercept(f(g(h())))`.
func (c *DoctorClient) Intercept(interceptors ...Interceptor) {
	c.inters.Doctor = append(c.inters.Doctor, interceptors...)
}

// Create returns a builder for creating a Doctor entity.
func (c *DoctorClient) Create() *DoctorCreate {
	mutation := newDoctorMutation(c.config, OpCreate)
	return &DoctorCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Doctor entities.
func (c *DoctorClient) CreateBulk(builders ...*DoctorCreate) *DoctorCreateBulk {
	return &DoctorCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DoctorClient) MapCreateBulk(slice any, setFunc func(*DoctorCreate, int)) *DoctorCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DoctorCreateBulk{err: fmt.Errorf("calling to DoctorClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DoctorCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DoctorCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Doctor.
func (c *DoctorClient) Update() *DoctorUpdate {
	mutation := newDoctorMutation(c.config, OpUpdate)
	return &DoctorUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DoctorClient) UpdateOne(_m *Doctor) *DoctorUpdateOne {
	mutation := newDoctorMutation(c.config, OpUpdateOne, withDoctor(_m))
	return &DoctorUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DoctorClient) UpdateOneID(id uuid.UUID) *DoctorUpdateOne {
	mutation := newDoctorMutation(c.config, OpUpdateOne, withDoctorID(id))
	return &DoctorUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Doctor.
func (c *DoctorClient) Delete() *DoctorDelete {
	mutation := newDoctorMutation(c.config, OpDelete)
	return &DoctorDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DoctorClient) DeleteOne(_m *Doctor) *DoctorDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DoctorClient) DeleteOneID(id uuid.UUID) *DoctorDeleteOne {
	builder := c.Delete().Where(doctor.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DoctorDeleteOne{builder}
}

// Query returns a query builder for Doctor.
func (c *DoctorClient) Query() *DoctorQuery {
	return &DoctorQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDoctor},
		inters: c.Interceptors(),
	}
}

// Get returns a Doctor entity by its id.
func (c *DoctorClient) Get(ctx context.Context, id uuid.UUID) (*Doctor, error) {
	return c.Query().Where(doctor.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DoctorClient) GetX(ctx context.Context, id uuid.UUID) *Doctor {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPractice queries the practice edge of a Doctor.
func (c *DoctorClient) QueryPractice(_m *Doctor) *PracticeQuery {
	query := (&PracticeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(doctor.Table, doctor.FieldID, id),
			sqlgraph.To(practice.Table, practice.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, doctor.PracticeTable, doctor.PracticeColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPatientLinks queries the patient_links edge of a Doctor.
func (c *DoctorClient) QueryPatientLinks(_m *Doctor) *DoctorPatientLinkQuery {
	query := (&DoctorPatientLinkClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(doctor.Table, doctor.FieldID, id),
			sqlgraph.To(doctorpatientlink.Table, doctorpatientlink.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, doctor.PatientLinksTable, doctor.PatientLinksColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPairingCodes queries the pairing_codes edge of a Doctor.
func (c *DoctorClient) QueryPairingCodes(_m *Doctor) *PairingCodeQuery {
	query := (&PairingCodeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(doctor.Table, doctor.FieldID, id),
			sqlgraph.To(pairingcode.Table, pairingcode.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, doctor.PairingCodesTable, doctor.PairingCodesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryApprovedPatientLinks queries the approved_patient_links edge of a Doctor.
func (c *DoctorClient) QueryApprovedPatientLinks(_m *Doctor) *DoctorPatientLinkQuery {
	query := (&DoctorPatientLinkClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(doctor.Table, doctor.FieldID, id),
			sqlgraph.To(doctorpatientlink.Table, doctorpatientlink.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, doctor.ApprovedPatientLinksTable, doctor.ApprovedPatientLinksColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEntryShares queries the entry_shares edge of a Doctor.
func (c *DoctorClient) QueryEntryShares(_m *Doctor) *EntryShareQuery {
	query := (&EntryShareClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(doctor.Table, doctor.FieldID, id),
			sqlgraph.To(entryshare.Table, entryshare.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, doctor.EntrySharesTable, doctor.EntrySharesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryComments queries the comments edge of a Doctor.
func (c *DoctorClient) QueryComments(_m *Doctor) *CommentQuery {
	query := (&CommentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(doctor.Table, doctor.FieldID, id),
			sqlgraph.To(comment.Table, comment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, doctor.CommentsTable, doctor.CommentsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCreatedAnalysisJobs queries the created_analysis_jobs edge of a Doctor.
func (c *DoctorClient) QueryCreatedAnalysisJobs(_m *Doctor) *AnalysisJobQuery {
	query := (&AnalysisJobClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(doctor.Table, doctor.FieldID, id),
			sqlgraph.To(analysisjob.Table, analysisjob.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, doctor.CreatedAnalysisJobsTable, doctor.CreatedAnalysisJobsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DoctorClient) Hooks() []Hook {
	return c.hooks.Doctor
}

// Interceptors returns the client interceptors.
func (c *DoctorClient) Interceptors() []Interceptor {
	return c.inters.Doctor
}

func (c *DoctorClient) mutate(ctx context.Context, m *DoctorMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DoctorCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DoctorUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DoctorUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DoctorDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Doctor mutation op: %q", m.Op())
	}
}

// DoctorPatientLinkClient is a client for the DoctorPatientLink schema.
type DoctorPatientLinkClient struct {
	config
}

// NewDoctorPatientLinkClient returns a client for the DoctorPatientLink from the given config.
func NewDoctorPatientLinkClient(c config) *DoctorPatientLinkClient {
	return &DoctorPatientLinkClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `doctorpatientlink.Hooks(f(g(h())))`.
func (c *DoctorPatientLinkClient) Use(hooks ...Hook) {
	c.hooks.DoctorPatientLink = append(c.hooks.DoctorPatientLink, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `doctorpatientlink.Intercept(f(g(h())))`.
func (c *DoctorPatientLinkClient) Intercept(interceptors ...Interceptor) {
	c.inters.DoctorPatientLink = append(c.inters.DoctorPatientLink, interceptors...)
}

// Create returns a builder for creating a DoctorPatientLink entity.
func (c *DoctorPatientLinkClient) Create() *DoctorPatientLinkCreate {
	mutation := newDoctorPatientLinkMutation(c.config, OpCreate)
	return &DoctorPatientLinkCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of DoctorPatientLink entities.
func (c *DoctorPatientLinkClient) CreateBulk(builders ...*DoctorPatientLinkCreate) *DoctorPatientLinkCreateBulk {
	return &DoctorPatientLinkCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DoctorPatientLinkClient) MapCreateBulk(slice any, setFunc func(*DoctorPatientLinkCreate, int)) *DoctorPatientLinkCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DoctorPatientLinkCreateBulk{err: fmt.Errorf("calling to DoctorPatientLinkClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DoctorPatientLinkCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DoctorPatientLinkCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for DoctorPatientLink.
func (c *DoctorPatientLinkClient) Update() *DoctorPatientLinkUpdate {
	mutation := newDoctorPatientLinkMutation(c.config, OpUpdate)
	return &DoctorPatientLinkUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DoctorPatientLinkClient) UpdateOne(_m *DoctorPatientLink) *DoctorPatientLinkUpdateOne {
	mutation := newDoctorPatientLinkMutation(c.config, OpUpdateOne, withDoctorPatientLink(_m))
	return &DoctorPatientLinkUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DoctorPatientLinkClient) UpdateOneID(id uuid.UUID) *DoctorPatientLinkUpdateOne {
	mutation := newDoctorPatientLinkMutation(c.config, OpUpdateOne, withDoctorPatientLinkID(id))
	return &DoctorPatientLinkUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for DoctorPatientLink.
func (c *DoctorPatientLinkClient) Delete() *DoctorPatientLinkDelete {
	mutation := newDoctorPatientLinkMutation(c.config, OpDelete)
	return &DoctorPatientLinkDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DoctorPatientLinkClient) DeleteOne(_m *DoctorPatientLink) *DoctorPatientLinkDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DoctorPatientLinkClient) DeleteOneID(id uuid.UUID) *DoctorPatientLinkDeleteOne {
	builder := c.Delete().Where(doctorpatientlink.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DoctorPatientLinkDeleteOne{builder}
}

// Query returns a query builder for DoctorPatientLink.
func (c *DoctorPatientLinkClient) Query() *DoctorPatientLinkQuery {
	return &DoctorPatientLinkQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDoctorPatientLink},
		inters: c.Interceptors(),
	}
}

// Get returns a DoctorPatientLink entity by its id.
func (c *DoctorPatientLinkClient) Get(ctx context.Context, id uuid.UUID) (*DoctorPatientLink, error) {
	return c.Query().Where(doctorpatientlink.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DoctorPatientLinkClient) GetX(ctx context.Context, id uuid.UUID) *DoctorPatientLink {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryDoctor queries the doctor edge of a DoctorPatientLink.
func (c *DoctorPatientLinkClient) QueryDoctor(_m *DoctorPatientLink) *DoctorQuery {
	query := (&DoctorClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(doctorpatientlink.Table, doctorpatientlink.FieldID, id),
			sqlgraph.To(doctor.Table, doctor.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, doctorpatientlink.DoctorTable, doctorpatientlink.DoctorColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPatient queries the patient edge of a DoctorPatientLink.
func (c *DoctorPatientLinkClient) QueryPatient(_m *DoctorPatientLink) *PatientQuery {
	query := (&PatientClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(doctorpatientlink.Table, doctorpatientlink.FieldID, id),
			sqlgraph.To(patient.Table, patient.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, doctorpatientlink.PatientTable, doctorpatientlink.PatientColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryApprovedBy queries the approved_by edge of a DoctorPatientLink.
func (c *DoctorPatientLinkClient) QueryApprovedBy(_m *DoctorPatientLink) *DoctorQuery {
	query := (&DoctorClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(doctorpatientlink.Table, doctorpatientlink.FieldID, id),
			sqlgraph.To(doctor.Table, doctor.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, doctorpatientlink.ApprovedByTable, doctorpatientlink.ApprovedByColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DoctorPatientLinkClient) Hooks() []Hook {
	return c.hooks.DoctorPatientLink
}

// Interceptors returns the client interceptors.
func (c *DoctorPatientLinkClient) Interceptors() []Interceptor {
	return c.inters.DoctorPatientLink
}

func (c *DoctorPatientLinkClient) mutate(ctx context.Context, m *DoctorPatientLinkMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DoctorPatientLinkCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DoctorPatientLinkUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DoctorPatientLinkUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DoctorPatientLinkDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown DoctorPatientLink mutation op: %q", m.Op())
	}
}

// EntryClient is a client for the Entry schema.
type EntryClient struct {
	config
}

// NewEntryClient returns a client for the Entry from the given config.
func NewEntryClient(c config) *EntryClient {
	return &EntryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `entry.Hooks(f(g(h())))`.
func (c *EntryClient) Use(hooks ...Hook) {
	c.hooks.Entry = append(c.hooks.Entry, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `entry.Intercept(f(g(h())))`.
func (c *EntryClient) Intercept(interceptors ...Interceptor) {
	c.inters.Entry = append(c.inters.Entry, interceptors...)
}

// Create returns a builder for creating a Entry entity.
func (c *EntryClient) Create() *EntryCreate {
	mutation := newEntryMutation(c.config, OpCreate)
	return &EntryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Entry entities.
func (c *EntryClient) CreateBulk(builders ...*EntryCreate) *EntryCreateBulk {
	return &EntryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *EntryClient) MapCreateBulk(slice any, setFunc func(*EntryCreate, int)) *EntryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &EntryCreateBulk{err: fmt.Errorf("calling to EntryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*EntryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &EntryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Entry.
func (c *EntryClient) Update() *EntryUpdate {
	mutation := newEntryMutation(c.config, OpUpdate)
	return &EntryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EntryClient) UpdateOne(_m *Entry) *EntryUpdateOne {
	mutation := newEntryMutation(c.config, OpUpdateOne, withEntry(_m))
	return &EntryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EntryClient) UpdateOneID(id uuid.UUID) *EntryUpdateOne {
	mutation := newEntryMutation(c.config, OpUpdateOne, withEntryID(id))
	return &EntryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Entry.
func (c *EntryClient) Delete() *EntryDelete {
	mutation := newEntryMutation(c.config, OpDelete)
	return &EntryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EntryClient) DeleteOne(_m *Entry) *EntryDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EntryClient) DeleteOneID(id uuid.UUID) *EntryDeleteOne {
	builder := c.Delete().Where(entry.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EntryDeleteOne{builder}
}

// Query returns a query builder for Entry.
func (c *EntryClient) Query() *EntryQuery {
	return &EntryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEntry},
		inters: c.Interceptors(),
	}
}

// Get returns a Entry entity by its id.
func (c *EntryClient) Get(ctx context.Context, id uuid.UUID) (*Entry, error) {
	return c.Query().Where(entry.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EntryClient) GetX(ctx context.Context, id uuid.UUID) *Entry {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPatient queries the patient edge of a Entry.
func (c *EntryClient) QueryPatient(_m *Entry) *PatientQuery {
	query := (&PatientClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(entry.Table, entry.FieldID, id),
			sqlgraph.To(patient.Table, patient.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, entry.PatientTable, entry.PatientColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryShares queries the shares edge of a Entry.
func (c *EntryClient) QueryShares(_m *Entry) *EntryShareQuery {
	query := (&EntryShareClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(entry.Table, entry.FieldID, id),
			sqlgraph.To(entryshare.Table, entryshare.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, entry.SharesTable, entry.SharesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryComments queries the comments edge of a Entry.
func (c *EntryClient) QueryComments(_m *Entry) *CommentQuery {
	query := (&CommentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(entry.Table, entry.FieldID, id),
			sqlgraph.To(comment.Table, comment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, entry.CommentsTable, entry.CommentsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAnalysisJobs queries the analysis_jobs edge of a Entry.
func (c *EntryClient) QueryAnalysisJobs(_m *Entry) *AnalysisJobQuery {
	query := (&AnalysisJobClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(entry.Table, entry.FieldID, id),
			sqlgraph.To(analysisjob.Table, analysisjob.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, entry.AnalysisJobsTable, entry.AnalysisJobsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *EntryClient) Hooks() []Hook {
	return c.hooks.Entry
}

// Interceptors returns the client interceptors.
func (c *EntryClient) Interceptors() []Interceptor {
	return c.inters.Entry
}

func (c *EntryClient) mutate(ctx context.Context, m *EntryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EntryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EntryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EntryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EntryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Entry mutation op: %q", m.Op())
	}
}

// EntryShareClient is a client for the EntryShare schema.
type EntryShareClient struct {
	config
}

// NewEntryShareClient returns a client for the EntryShare from the given config.
func NewEntryShareClient(c config) *EntryShareClient {
	return &EntryShareClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `entryshare.Hooks(f(g(h())))`.
func (c *EntryShareClient) Use(hooks ...Hook) {
	c.hooks.EntryShare = append(c.hooks.EntryShare, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `entryshare.Intercept(f(g(h())))`.
func (c *EntryShareClient) Intercept(interceptors ...Interceptor) {
	c.inters.EntryShare = append(c.inters.EntryShare, interceptors...)
}

// Create returns a builder for creating a EntryShare entity.
func (c *EntryShareClient) Create() *EntryShareCreate {
	mutation := newEntryShareMutation(c.config, OpCreate)
	return &EntryShareCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of EntryShare entities.
func (c *EntryShareClient) CreateBulk(builders ...*EntryShareCreate) *EntryShareCreateBulk {
	return &EntryShareCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *EntryShareClient) MapCreateBulk(slice any, setFunc func(*EntryShareCreate, int)) *EntryShareCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &EntryShareCreateBulk{err: fmt.Errorf("calling to EntryShareClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*EntryShareCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &EntryShareCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for EntryShare.
func (c *EntryShareClient) Update() *EntryShareUpdate {
	mutation := newEntryShareMutation(c.config, OpUpdate)
	return &EntryShareUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EntryShareClient) UpdateOne(_m *EntryShare) *EntryShareUpdateOne {
	mutation := newEntryShareMutation(c.config, OpUpdateOne, withEntryShare(_m))
	return &EntryShareUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EntryShareClient) UpdateOneID(id uuid.UUID) *EntryShareUpdateOne {
	mutation := newEntryShareMutation(c.config, OpUpdateOne, withEntryShareID(id))
	return &EntryShareUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for EntryShare.
func (c *EntryShareClient) Delete() *EntryShareDelete {
	mutation := newEntryShareMutation(c.config, OpDelete)
	return &EntryShareDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EntryShareClient) DeleteOne(_m *EntryShare) *EntryShareDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EntryShareClient) DeleteOneID(id uuid.UUID) *EntryShareDeleteOne {
	builder := c.Delete().Where(entryshare.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EntryShareDeleteOne{builder}
}

// Query returns a query builder for EntryShare.
func (c *EntryShareClient) Query() *EntryShareQuery {
	return &EntryShareQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEntryShare},
		inters: c.Interceptors(),
	}
}

// Get returns a EntryShare entity by its id.
func (c *EntryShareClient) Get(ctx context.Context, id uuid.UUID) (*EntryShare, error) {
	return c.Query().Where(entryshare.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EntryShareClient) GetX(ctx context.Context, id uuid.UUID) *EntryShare {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryEntry queries the entry edge of a EntryShare.
func (c *EntryShareClient) QueryEntry(_m *EntryShare) *EntryQuery {
	query := (&EntryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(entryshare.Table, entryshare.FieldID, id),
			sqlgraph.To(entry.Table, entry.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, entryshare.EntryTable, entryshare.EntryColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySharedByPatient queries the shared_by_patient edge of a EntryShare.
func (c *EntryShareClient) QuerySharedByPatient(_m *EntryShare) *PatientQuery {
	query := (&PatientClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(entryshare.Table, entryshare.FieldID, id),
			sqlgraph.To(patient.Table, patient.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, entryshare.SharedByPatientTable, entryshare.SharedByPatientColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySharedWithDoctor queries the shared_with_doctor edge of a EntryShare.
func (c *EntryShareClient) QuerySharedWithDoctor(_m *EntryShare) *DoctorQuery {
	query := (&DoctorClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(entryshare.Table, entryshare.FieldID, id),
			sqlgraph.To(doctor.Table, doctor.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, entryshare.SharedWithDoctorTable, entryshare.SharedWithDoctorColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *EntryShareClient) Hooks() []Hook {
	return c.hooks.EntryShare
}

// Interceptors returns the client interceptors.
func (c *EntryShareClient) Interceptors() []Interceptor {
	return c.inters.EntryShare
}

func (c *EntryShareClient) mutate(ctx context.Context, m *EntryShareMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EntryShareCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EntryShareUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EntryShareUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EntryShareDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown EntryShare mutation op: %q", m.Op())
	}
}

// PairingCodeClient is a client for the PairingCode schema.
type PairingCodeClient struct {
	config
}

// NewPairingCodeClient returns a client for the PairingCode from the given config.
func NewPairingCodeClient(c config) *PairingCodeClient {
	return &PairingCodeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `pairingcode.Hooks(f(g(h())))`.
func (c *PairingCodeClient) Use(hooks ...Hook) {
	c.hooks.PairingCode = append(c.hooks.PairingCode, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `pairingcode.Intercept(f(g(h())))`.
func (c *PairingCodeClient) Intercept(interceptors ...Interceptor) {
	c.inters.PairingCode = append(c.inters.PairingCode, interceptors...)
}

// Create returns a builder for creating a PairingCode entity.
func (c *PairingCodeClient) Create() *PairingCodeCreate {
	mutation := newPairingCodeMutation(c.config, OpCreate)
	return &PairingCodeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PairingCode entities.
func (c *PairingCodeClient) CreateBulk(builders ...*PairingCodeCreate) *PairingCodeCreateBulk {
	return &PairingCodeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PairingCodeClient) MapCreateBulk(slice any, setFunc func(*PairingCodeCreate, int)) *PairingCodeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PairingCodeCreateBulk{err: fmt.Errorf("calling to PairingCodeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PairingCodeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PairingCodeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PairingCode.
func (c *PairingCodeClient) Update() *PairingCodeUpdate {
	mutation := newPairingCodeMutation(c.config, OpUpdate)
	return &PairingCodeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PairingCodeClient) UpdateOne(_m *PairingCode) *PairingCodeUpdateOne {
	mutation := newPairingCodeMutation(c.config, OpUpdateOne, withPairingCode(_m))
	return &PairingCodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PairingCodeClient) UpdateOneID(id uuid.UUID) *PairingCodeUpdateOne {
	mutation := newPairingCodeMutation(c.config, OpUpdateOne, withPairingCodeID(id))
	return &PairingCodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PairingCode.
func (c *PairingCodeClient) Delete() *PairingCodeDelete {
	mutation := newPairingCodeMutation(c.config, OpDelete)
	return &PairingCodeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PairingCodeClient) DeleteOne(_m *PairingCode) *PairingCodeDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PairingCodeClient) DeleteOneID(id uuid.UUID) *PairingCodeDeleteOne {
	builder := c.Delete().Where(pairingcode.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PairingCodeDeleteOne{builder}
}

// Query returns a query builder for PairingCode.
func (c *PairingCodeClient) Query() *PairingCodeQuery {
	return &PairingCodeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePairingCode},
		inters: c.Interceptors(),
	}
}

// Get returns a PairingCode entity by its id.
func (c *PairingCodeClient) Get(ctx context.Context, id uuid.UUID) (*PairingCode, error) {
	return c.Query().Where(pairingcode.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PairingCodeClient) GetX(ctx context.Context, id uuid.UUID) *PairingCode {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryDoctor queries the doctor edge of a PairingCode.
func (c *PairingCodeClient) QueryDoctor(_m *PairingCode) *DoctorQuery {
	query := (&DoctorClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(pairingcode.Table, pairingcode.FieldID, id),
			sqlgraph.To(doctor.Table, doctor.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, pairingcode.DoctorTable, pairingcode.DoctorColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryConsumedByPatient queries the consumed_by_patient edge of a PairingCode.
func (c *PairingCodeClient) QueryConsumedByPatient(_m *PairingCode) *PatientQuery {
	query := (&PatientClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(pairingcode.Table, pairingcode.FieldID, id),
			sqlgraph.To(patient.Table, patient.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, pairingcode.ConsumedByPatientTable, pairingcode.ConsumedByPatientColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PairingCodeClient) Hooks() []Hook {
	return c.hooks.PairingCode
}

// Interceptors returns the client interceptors.
func (c *PairingCodeClient) Interceptors() []Interceptor {
	return c.inters.PairingCode
}

func (c *PairingCodeClient) mutate(ctx context.Context, m *PairingCodeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PairingCodeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PairingCodeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PairingCodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PairingCodeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PairingCode mutation op: %q", m.Op())
	}
}

// PatientClient is a client for the Patient schema.
type PatientClient struct {
	config
}

// NewPatientClient returns a client for the Patient from the given config.
func NewPatientClient(c config) *PatientClient {
	return &PatientClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `patient.Hooks(f(g(h())))`.
func (c *PatientClient) Use(hooks ...Hook) {
	c.hooks.Patient = append(c.hooks.Patient, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `patient.Intercept(f(g(h())))`.
func (c *PatientClient) Intercept(interceptors ...Interceptor) {
	c.inters.Patient = append(c.inters.Patient, interceptors...)
}

// Create returns a builder for creating a Patient entity.
func (c *PatientClient) Create() *PatientCreate {
	mutation := newPatientMutation(c.config, OpCreate)
	return &PatientCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Patient entities.
func (c *PatientClient) CreateBulk(builders ...*PatientCreate) *PatientCreateBulk {
	return &PatientCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PatientClient) MapCreateBulk(slice any, setFunc func(*PatientCreate, int)) *PatientCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PatientCreateBulk{err: fmt.Errorf("calling to PatientClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PatientCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PatientCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Patient.
func (c *PatientClient) Update() *PatientUpdate {
	mutation := newPatientMutation(c.config, OpUpdate)
	return &PatientUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PatientClient) UpdateOne(_m *Patient) *PatientUpdateOne {
	mutation := newPatientMutation(c.config, OpUpdateOne, withPatient(_m))
	return &PatientUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PatientClient) UpdateOneID(id uuid.UUID) *PatientUpdateOne {
	mutation := newPatientMutation(c.config, OpUpdateOne, withPatientID(id))
	return &PatientUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Patient.
func (c *PatientClient) Delete() *PatientDelete {
	mutation := newPatientMutation(c.config, OpDelete)
	return &PatientDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PatientClient) DeleteOne(_m *Patient) *PatientDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PatientClient) DeleteOneID(id uuid.UUID) *PatientDeleteOne {
	builder := c.Delete().Where(patient.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PatientDeleteOne{builder}
}

// Query returns a query builder for Patient.
func (c *PatientClient) Query() *PatientQuery {
	return &PatientQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePatient},
		inters: c.Interceptors(),
	}
}

// Get returns a Patient entity by its id.
func (c *PatientClient) Get(ctx context.Context, id uuid.UUID) (*Patient, error) {
	return c.Query().Where(patient.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PatientClient) GetX(ctx context.Context, id uuid.UUID) *Patient {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryDoctorLinks queries the doctor_links edge of a Patient.
func (c *PatientClient) QueryDoctorLinks(_m *Patient) *DoctorPatientLinkQuery {
	query := (&DoctorPatientLinkClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(patient.Table, patient.FieldID, id),
			sqlgraph.To(doctorpatientlink.Table, doctorpatientlink.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, patient.DoctorLinksTable, patient.DoctorLinksColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryConsumedPairingCodes queries the consumed_pairing_codes edge of a Patient.
func (c *PatientClient) QueryConsumedPairingCodes(_m *Patient) *PairingCodeQuery {
	query := (&PairingCodeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(patient.Table, patient.FieldID, id),
			sqlgraph.To(pairingcode.Table, pairingcode.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, patient.ConsumedPairingCodesTable, patient.ConsumedPairingCodesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEntries queries the entries edge of a Patient.
func (c *PatientClient) QueryEntries(_m *Patient) *EntryQuery {
	query := (&EntryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(patient.Table, patient.FieldID, id),
			sqlgraph.To(entry.Table, entry.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, patient.EntriesTable, patient.EntriesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAnalysisJobs queries the analysis_jobs edge of a Patient.
func (c *PatientClient) QueryAnalysisJobs(_m *Patient) *AnalysisJobQuery {
	query := (&AnalysisJobClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(patient.Table, patient.FieldID, id),
			sqlgraph.To(analysisjob.Table, analysisjob.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, patient.AnalysisJobsTable, patient.AnalysisJobsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEntryShares queries the entry_shares edge of a Patient.
func (c *PatientClient) QueryEntryShares(_m *Patient) *EntryShareQuery {
	query := (&EntryShareClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(patient.Table, patient.FieldID, id),
			sqlgraph.To(entryshare.Table, entryshare.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, patient.EntrySharesTable, patient.EntrySharesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PatientClient) Hooks() []Hook {
	return c.hooks.Patient
}

// Interceptors returns the client interceptors.
func (c *PatientClient) Interceptors() []Interceptor {
	return c.inters.Patient
}

func (c *PatientClient) mutate(ctx context.Context, m *PatientMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PatientCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PatientUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PatientUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PatientDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Patient mutation op: %q", m.Op())
	}
}

// PracticeClient is a client for the Practice schema.
type PracticeClient struct {
	config
}

// NewPracticeClient returns a client for the Practice from the given config.
func NewPracticeClient(c config) *PracticeClient {
	return &PracticeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `practice.Hooks(f(g(h())))`.
func (c *PracticeClient) Use(hooks ...Hook) {
	c.hooks.Practice = append(c.hooks.Practice, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `practice.Intercept(f(g(h())))`.
func (c *PracticeClient) Intercept(interceptors ...Interceptor) {
	c.inters.Practice = append(c.inters.Practice, interceptors...)
}

// Create returns a builder for creating a Practice entity.
func (c *PracticeClient) Create() *PracticeCreate {
	mutation := newPracticeMutation(c.config, OpCreate)
	return &PracticeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Practice entities.
func (c *PracticeClient) CreateBulk(builders ...*PracticeCreate) *PracticeCreateBulk {
	return &PracticeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PracticeClient) MapCreateBulk(slice any, setFunc func(*PracticeCreate, int)) *PracticeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PracticeCreateBulk{err: fmt.Errorf("calling to PracticeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PracticeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PracticeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Practice.
func (c *PracticeClient) Update() *PracticeUpdate {
	mutation := newPracticeMutation(c.config, OpUpdate)
	return &PracticeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PracticeClient) UpdateOne(_m *Practice) *PracticeUpdateOne {
	mutation := newPracticeMutation(c.config, OpUpdateOne, withPractice(_m))
	return &PracticeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PracticeClient) UpdateOneID(id uuid.UUID) *PracticeUpdateOne {
	mutation := newPracticeMutation(c.config, OpUpdateOne, withPracticeID(id))
	return &PracticeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Practice.
func (c *PracticeClient) Delete() *PracticeDelete {
	mutation := newPracticeMutation(c.config, OpDelete)
	return &PracticeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PracticeClient) DeleteOne(_m *Practice) *PracticeDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PracticeClient) DeleteOneID(id uuid.UUID) *PracticeDeleteOne {
	builder := c.Delete().Where(practice.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PracticeDeleteOne{builder}
}

// Query returns a query builder for Practice.
func (c *PracticeClient) Query() *PracticeQuery {
	return &PracticeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePractice},
		inters: c.Interceptors(),
	}
}

// Get returns a Practice entity by its id.
func (c *PracticeClient) Get(ctx context.Context, id uuid.UUID) (*Practice, error) {
	return c.Query().Where(practice.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PracticeClient) GetX(ctx context.Context, id uuid.UUID) *Practice {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryDoctors queries the doctors edge of a Practice.
func (c *PracticeClient) QueryDoctors(_m *Practice) *DoctorQuery {
	query := (&DoctorClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(practice.Table, practice.FieldID, id),
			sqlgraph.To(doctor.Table, doctor.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, practice.DoctorsTable, practice.DoctorsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PracticeClient) Hooks() []Hook {
	return c.hooks.Practice
}

// Interceptors returns the client interceptors.
func (c *PracticeClient) Interceptors() []Interceptor {
	return c.inters.Practice
}

func (c *PracticeClient) mutate(ctx context.Context, m *PracticeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PracticeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PracticeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PracticeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PracticeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Practice mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		AnalysisJob, Comment, Doctor, DoctorPatientLink, Entry, EntryShare, PairingCode,
		Patient, Practice []ent.Hook
	}
	inters struct {
		AnalysisJob, Comment, Doctor, DoctorPatientLink, Entry, EntryShare, PairingCode,
		Patient, Practice []ent.Interceptor
	}
)
